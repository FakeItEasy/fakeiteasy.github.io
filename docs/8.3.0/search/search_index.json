{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FakeItEasy","text":"<p>FakeItEasy is a .NET dynamic fake library for creating all types of fake objects, mocks, stubs etc.</p> <ul> <li>Easier semantics, all fake objects are just that - fakes - the use of the fakes determines whether they're mocks or stubs.</li> <li>Context-aware fluent interface guides the developer.</li> <li>Designed for ease of use.</li> <li>Full compatibility with both C# and VB.NET.</li> </ul>"},{"location":"#its-faking-amazing","title":"It's faking amazing!","text":"<ul> <li>Website</li> <li>Quickstart</li> <li>Chat</li> <li>Package</li> </ul> <p>FakeItEasy logo designed by Vanja Pakaski.</p>"},{"location":"advanced-usage/","title":"Advanced usage","text":"<p>FakeItEasy exposes a few APIs that aren't commonly needed, but can be useful in certain scenarios.</p>"},{"location":"advanced-usage/#resetting-a-fake-to-its-initial-state","title":"Resetting a fake to its initial state","text":"<p>In most cases, you should just discard the fake after use and create a new one; in other words, don't reuse a fake between tests if you can avoid it.</p> <p>However, in some situations this might not be practical. To actually reset a fake to its initial state, use the <code>Fake.Reset</code> method:</p> <pre><code>Fake.Reset(fake);\n</code></pre> <p>This method resets all changes made to the fake after it was created. This includes: * call configurations * values of auto-faked read-write properties * event handlers * recorded calls * interception listeners</p> <p>However, any changes made during fake creation (via fake creation options) will be preserved. This includes all the elements mentioned above, but also: * strictness, * object wrapping, * redirecting to base methods, and * other explicit or   implicit creation options.</p>"},{"location":"advanced-usage/#clearing-a-fakes-recorded-calls","title":"Clearing a fake's recorded calls","text":"<p>The <code>Fake.ClearRecordedCalls</code> method clears all recorded calls from a fake. Subsequent call assertions won't see these calls.</p> <pre><code>var foo = A.Fake&lt;IFoo&gt;();\nfoo.Bar();\nA.CallTo(() =&gt; foo.Bar()).MustHaveHappened();\nFake.ClearRecordedCalls(foo);\nA.CallTo(() =&gt; foo.Bar()).MustNotHaveHappened();\n</code></pre>"},{"location":"advanced-usage/#getting-the-list-of-calls-made-on-a-fake","title":"Getting the list of calls made on a fake","text":"<p>Sometimes, the call assertion API offered by FakeItEasy isn't enough, and you need to manually check the calls made on a fake. The <code>Fake.GetCalls</code> method returns a fake's recorded calls as a list of <code>ICompletedFakeObjectCall</code> objects that you can examine yourself:</p> <pre><code>var foo = A.Fake&lt;IFoo&gt;();\nfoo.Bar();\nfoo.Baz();\nvar calls = Fake.GetCalls(foo).ToList();\nAssert.Equal(2, calls.Count);\nAssert.Equal(\"Bar\", calls[0].Method.Name);\nAssert.Equal(\"Baz\", calls[1].Method.Name);\n</code></pre>"},{"location":"advanced-usage/#the-fakemanager-object","title":"The <code>FakeManager</code> object","text":"<p>The <code>Fake.GetFakeManager</code> method returns a <code>FakeManager</code> object that can be used to get information on the fake and manipulate its call rules.</p> <p><code>Fake.GetFakeManager</code> throws an exception if the provided object is not a fake. To test if an object is a fake you can call <code>Fake.IsFake</code> or try get the <code>FakeManager</code> with <code>Fake.TryGetFakeManager</code> which will return true if the provided object is a fake and also give you the <code>FakeManager</code> for that object via an out parameter.</p>"},{"location":"advanced-usage/#getting-the-type-of-the-fake","title":"Getting the type of the fake","text":"<p>The <code>FakeManager.FakeObjectType</code> property returns the type of the fake, i.e. the type that was passed to <code>A.Fake</code>. This can be useful if you're writing code that dynamically manipulates fakes.</p> <pre><code>var foo = A.Fake&lt;IFoo&gt;();\nvar manager = Fake.GetFakeManager(foo);\nAssert.Equal(typeof(IFoo), manager.FakeObjectType);\n</code></pre>"},{"location":"advanced-usage/#getting-the-fake-from-the-fake-manager","title":"Getting the fake from the fake manager","text":"<p>The <code>FakeManager.Object</code> property returns the fake object managed by this <code>FakeManager</code>.</p> <pre><code>var foo = A.Fake&lt;IFoo&gt;();\nvar manager = Fake.GetFakeManager(foo);\nAssert.Equal(foo, manager.Object);\n</code></pre>"},{"location":"advanced-usage/#manipulating-a-fakes-call-rules","title":"Manipulating a fake's call rules","text":"<p>The <code>FakeManager.Rules</code> property returns all the rules configured on a fake.</p> <pre><code>var foo = A.Fake&lt;IFoo&gt;();\nA.CallTo(() =&gt; foo.Bar()).Returns(42);\nA.CallTo(() =&gt; foo.Baz()).DoesNothing();\nvar manager = Fake.GetFakeManager(foo);\nvar rules = manager.Rules.ToList();\nAssert.Equal(2, rules.Count);\n</code></pre> <p>It is also possible to add custom rules for advanced scenarios, using <code>AddRuleFirst</code> and <code>AddRuleLast</code>. <code>AddRuleFirst</code> adds a rule at the beginning of the rule list, so that it's considered before any other rule (which is the normal behavior when configuring a fake with  <code>A.CallTo(...)</code>). <code>AddRuleLast</code> adds a rule at the end of the rule list, so that it's considered after any other rule.</p> <pre><code>class MyRule : IFakeObjectCallRule\n{\npublic int? NumberOfTimesToCall =&gt; null;\npublic void Apply(IInterceptedFakeObjectCall fakeObjectCall)\n{\nfakeObjectCall.SetReturnValue(42);\n}\npublic bool IsApplicableTo(IFakeObjectCall fakeObjectCall)\n{\nreturn fakeObjectCall.Method.DeclaringType == typeof(IFoo)\n&amp;&amp; fakeObjectCall.Method.Name == \"Bar\";\n}\n}\n...\nvar foo = A.Fake&lt;IFoo&gt;();\nvar manager = Fake.GetFakeManager(foo);\nmanager.AddRuleFirst(new MyRule());\nAssert.Equal(42, foo.Bar());\n</code></pre> <p>You can also remove a rule using the <code>RemoveRule</code> method.</p> <p>Note that if your custom rule is stateful, you should implement the <code>IStatefulFakeObjectCallRule</code> interface to provide a way to get a snapshot of the current state of your rule. This is necessary for <code>Fake.Reset</code> to work correctly.</p>"},{"location":"advanced-usage/#intercepting-calls","title":"Intercepting calls","text":"<p>Using the <code>FakeManager.AddInterceptionListener</code> method, you can add a listener that is called every time a fake method is called.</p> <pre><code>class MyListener : IInterceptionListener\n{\npublic void OnBeforeCallIntercepted(IFakeObjectCall interceptedCall)\n{\nConsole.WriteLine($\"A call to '{interceptedCall.Method}' is about to be processed\");\n}\npublic void OnAfterCallIntercepted(ICompletedFakeObjectCall interceptedCall)\n{\nConsole.WriteLine($\"A call to '{interceptedCall.Method}' has been processed\");\n}\n}\n...\nvar foo = A.Fake&lt;IFoo&gt;();\nA.CallTo(() =&gt; foo.Baz()).Invokes(() =&gt; Console.WriteLine(\"Hello world\"));\nvar manager = Fake.GetFakeManager(foo);\nmanager.AddInterceptionListener(new MyListener());\nfoo.Baz();\n</code></pre> <p>The code above prints:</p> <pre><code>A call to 'Void Baz()' is about to be processed\nHello world\nA call to 'Void Baz()' has been processed\n</code></pre>"},{"location":"analyzer/","title":"Analyzer","text":"<p>The contents of this page have moved. See the FakeItEasy Analyzer Packages documentation for information about the FakeItEasy Analyzer packages.</p>"},{"location":"argument-constraints/","title":"Argument constraints","text":"<p>When configuring and asserting calls in FakeItEasy, the arguments of the call can be constrained so that only calls to the configured method where the arguments matches the constraint are selected.</p>"},{"location":"argument-constraints/#matching-values-exactly","title":"Matching values exactly","text":"<p>Assume the following interface exists: <pre><code>public interface IFoo\n{\nvoid Bar(string s, int i);\n}\n</code></pre></p> <p>Then the arguments to Bar can be constrained to limit call matching: <pre><code>var foo = A.Fake&lt;IFoo&gt;();\nA.CallTo(() =&gt; foo.Bar(\"hello\", 17)).MustHaveHappened();\n</code></pre></p> <p>Then FakeItEasy will look only for calls made with the arguments <code>\"hello\"</code> and <code>17</code> - no other calls will match the rule.</p> <p>When checking for argument equality, FakeItEasy uses the first applicable equality test from this list:</p> <ul> <li>if both values are <code>null</code>, they are considered equal,</li> <li>if one value is <code>null</code> and the other isn't, they are not considered equal,</li> <li>the highest-priority custom argument equality comparer   that can compare the example object's type, or</li> <li>if both values are <code>string</code>, <code>string.Equals</code> (as an optimization),</li> <li>if the example object's type implements <code>System.Collections.IEnumerable</code>, the values   are considered equal if and only if the actual object's type also implements   <code>System.Collections.IEnumerable</code> and <code>System.Linq.Enumerable.SequenceEqual</code> evaluates   to true, or</li> <li><code>Object.Equals</code></li> </ul> <p>If this list is not satisfactory, you may have to use the <code>That.Matches</code> method described in Custom matching. Be particularly careful of types whose <code>Equals</code> methods perform reference equality rather than value equality. In that case, the objects have to be the same object in order to match, and this sometimes produces unexpected results. When in doubt, verify the type's <code>Equals</code> behavior manually.</p>"},{"location":"argument-constraints/#other-matchers","title":"Other matchers","text":""},{"location":"argument-constraints/#ignoring-arguments","title":"Ignoring arguments","text":"<p>Suppose the value of the integer in the <code>Bar</code> call wasn't important, but the string was. Then the following constraint could be used:</p> <pre><code>A.CallTo(() =&gt; foo.Bar(\"hello\", A&lt;int&gt;.Ignored)).MustHaveHappened();\n</code></pre> <p>Then any call will match, so long as the string value was <code>\"hello\"</code>. The <code>Ignored</code> property can be used on any type.</p> <p>An underscore (<code>_</code>) can be used as a shorthand for <code>Ignored</code> as well: <pre><code>A.CallTo(() =&gt; foo.Bar(\"hello\", A&lt;int&gt;._)).MustHaveHappened();\n</code></pre></p>"},{"location":"argument-constraints/#more-convenience-matchers","title":"More convenience matchers","text":"<p>If more complicated constraints are needed, the <code>That</code> method can be used. There are a few built-in matchers:</p> Matcher Tests for IsNull() <code>null</code> IsNotNull() not <code>null</code> IsEqualTo(other) object equality using <code>object.Equals</code> IsEqualTo(other, equalityComparer) object equality using <code>equalityComparer.Equals</code> IsSameAs(other) object identity - like <code>object.ReferenceEquals</code> IsInstanceOf(type) an argument that can be assigned to a variable of type <code>type</code> Contains(string) substring match with ordinal string comparison Contains(string, comparisonType) substring match with the specified comparison type StartsWith(string) substring at beginning of string with ordinal string comparison StartsWith(string, comparisonType) substring at beginning of string with the specified comparison type EndsWith(string) substring at end of string with ordinal string comparison EndsWith(string, comparisonType) substring at end of string with the specified comparison type IsNullOrEmpty() <code>null</code> or <code>\"\"</code> IsEmpty() empty enumerable Contains(item) item's presence in an enumerable IsSameSequenceAs(enumerable) sequence equality, like <code>System.Linq.Enumerable.SequenceEqual</code> IsSameSequenceAs(value1, value2, ...) sequence equality, like <code>System.Linq.Enumerable.SequenceEqual</code> Not inverts the sense of the matcher"},{"location":"argument-constraints/#custom-matching","title":"Custom matching","text":"<p>If none of the canned matchers are sufficient, you can provide a predicate to perform custom matching using <code>That.Matches</code>. Like in this rather contrived example:</p> <pre><code>A&lt;string&gt;.That.Matches(s =&gt; s.Length == 3 &amp;&amp; s[1] == 'X');\n</code></pre> <p>FakeItEasy will evaluate the predicate against any supplied argument. The predicate can be supplied as an <code>Expression&lt;Func&lt;T, bool&gt;&gt;</code> or as a <code>Func&lt;T, bool&gt;</code>. FakeItEasy can generate a description of the matcher when an <code>Expression</code> is supplied (although you may supply your own as well), but you must supply a description when using a <code>Func</code>.</p> <p>For another example of using <code>That.Matches</code>, see Jonathan Channon's Comparing object instances with FakeItEasy.</p>"},{"location":"argument-constraints/#always-place-ignored-and-that-inside-acallto","title":"Always place <code>Ignored</code> and <code>That</code> inside <code>A.CallTo</code>","text":"<p>The <code>Ignored</code> (and <code>_</code>) and <code>That</code> matchers must be placed within the expression inside the <code>A.CallTo</code> call. This is because these special constraint methods do not return an actual matcher object. They tell FakeItEasy how to match the parameter via a special event that's fired when the constraint method is invoked. FakeItEasy only listens to the events in the context of an <code>A.CallTo</code>.</p> <p>So, tempting as it might be to save one of the constraints away in a handy variable, don't do it.</p>"},{"location":"argument-constraints/#using-correct-grammar","title":"Using correct grammar","text":"<p>FakeItEasy's API attempts to imitate the English language, so that call configurations and assertions read naturally. In that spirit, it's possible to use <code>An&lt;T&gt;</code> instead of <code>A&lt;T&gt;</code> for types whose name starts with a vowel sound. For instance:</p> <pre><code>An&lt;Apple&gt;.That.Matches(a =&gt; a.Color == \"Red\")\n</code></pre> <p><code>A&lt;T&gt;</code> and <code>An&lt;T&gt;</code> are exact synonyms and can be used exactly the same way.</p>"},{"location":"argument-constraints/#out-parameters","title":"<code>out</code> parameters","text":"<p>The incoming argument value of <code>out</code> parameters is ignored when matching calls. The incoming value of an <code>out</code> parameter can't be seen by the method body anyhow, so there's no advantage to constraining by it.</p> <p>For example, this test passes:</p> <pre><code>string configurationValue = \"lollipop\";\nA.CallTo(() =&gt; aFakeDictionary.TryGetValue(theKey, out configurationValue))\n.Returns(true);\nstring fetchedValue = \"licorice\";\nvar success = aFakeDictionary.TryGetValue(theKey, out fetchedValue);\nAssert.That(success, Is.True);\n</code></pre> <p>See Implicitly Assigning <code>out</code> Parameter Values to learn how the initial <code>configurationValue</code> is used in this case.</p>"},{"location":"argument-constraints/#ref-parameters","title":"<code>ref</code> parameters","text":"<p>Due to the limitations of working with <code>ref</code> parameters in C#, only exact-value matching is possible using argument constraints, and the argument value must be compared against a local variable or a field:</p> <pre><code>int someValue = 3;\nA.CallTo(() =&gt; aFake.aMethod(ref someValue)).Returns(true);\n</code></pre> <p>To perform more sophisticated matching of <code>ref</code> parameter values in C#, use constraints that work on the entire call, such as <code>WithAnyArguments</code> or <code>WhenArgumentsMatch</code>, described below.</p> <p>In addition to constraining by <code>ref</code> argument values, calls can be explicitly configured to assign outgoing <code>ref</code> argument values.</p>"},{"location":"argument-constraints/#arguments-of-anonymous-types","title":"Arguments of anonymous types","text":"<p>Anonymous types are not shared between assemblies, so it's not possible to make an argument constraint that matches an anonymous type from another assembly. Instead, you may use <code>A.CallTo(fake).Where(...)</code> as described in Specifying a call to any method or property.</p>"},{"location":"argument-constraints/#overriding-argument-matchers","title":"Overriding argument matchers","text":"<p>Sometimes individually constraining arguments isn't sufficient. In such a case, other methods may be used to determine which calls match the fake's configuration.</p> <p>When using the following methods, any inline argument constraints are ignored, and only the special method is used to match the call. Some arguments have to be supplied in order to satisfy the compiler, but the values will not be used, so you can supply whatever values make the code easiest for you to read.</p> <p><code>WithAnyArguments</code> ensures that no argument constraints will be applied when matching calls:</p> <pre><code>A.CallTo(() =&gt; foo.Bar(null, 7)).WithAnyArguments().MustHaveHappened();\n</code></pre> <p>The example above will match any call to <code>foo.Bar</code>, regardless of the arguments. The <code>Ignored</code> property performs the same task, and is more flexible, but some people prefer the look of <code>WithAnyArguments</code>.</p> <p><code>WhenArgumentsMatch</code> accepts a predicate that operates on the entire collection of call arguments.  For example, to have a Fake throw an exception when a call is made to <code>Bar</code> where the first arguments is a string representation of the second, use</p> <pre><code>A.CallTo(() =&gt; fake.Bar(null, 0))\n.WhenArgumentsMatch(args =&gt;\nargs.Get&lt;string&gt;(\"theString\")\n.Equals(args.Get&lt;int&gt;(\"theInt\").ToString()))\n.Throws&lt;Exception&gt;();\n</code></pre> <p>Strongly typed overloads of <code>WhenArgumentsMatch</code> are also available for methods of up to 8 parameters (if a method has more parameters, use the variant described above):</p> <pre><code>A.CallTo(() =&gt; fake.Bar(null, 0))\n.WhenArgumentsMatch((string theString, int theInt) =&gt;\ntheString.Equals(theInt.ToString()))\n.Throws&lt;Exception&gt;();\n</code></pre>"},{"location":"argument-constraints/#capturing-arguments","title":"Capturing arguments","text":"<p>It is also possible to capture arguments passed to a call, whether you also want to constrain those arguments or not, and verify the passed values after the fact.</p>"},{"location":"argument-constraints/#nested-argument-constraints","title":"Nested argument constraints","text":"<p>Note that an argument constraint cannot be \"nested\" in an argument; the constraint has to be the whole argument. For instance, the following call configurations are invalid and will throw an exception:</p> <pre><code>A.CallTo(() =&gt; fake.Foo(new Bar(A&lt;int&gt;._))).Returns(42);\nA.CallTo(() =&gt; fake.Foo(new Bar { X = A&lt;string&gt;.That.Contains(\"hello\") })).Returns(42);\n</code></pre> <p>To achieve the desired effect, you can do this instead:</p> <pre><code>A.CallTo(() =&gt; fake.Foo(A&lt;Bar&gt;._)).Returns(42);\nA.CallTo(() =&gt; fake.Foo(A&lt;Bar&gt;.That.Matches(bar =&gt; bar.X.Contains(\"hello\")))).Returns(42);\n</code></pre>"},{"location":"assertion/","title":"Assertion","text":"<p>Assertion uses exactly the same syntax as configuration to specify the call to be asserted, followed by a method call beginning with <code>.MustHaveHappened</code>.</p> <p>The two most common forms of assertion are :</p> <ul> <li><code>MustHaveHappened()</code> (no arguments) asserts that the call was made 1 or more times, and </li> <li><code>MustNotHaveHappened()</code> asserts that the specified call did not happen at all.</li> </ul> <p>Arguments are constrained using Argument Constraints just like when configuring calls.</p>"},{"location":"assertion/#syntax","title":"Syntax","text":"<pre><code>A.CallTo(() =&gt; foo.Bar()).MustHaveHappened();\nA.CallTo(() =&gt; foo.Bar()).MustNotHaveHappened();\nA.CallTo(() =&gt; foo.Bar()).MustHaveHappenedOnceExactly();\nA.CallTo(() =&gt; foo.Bar()).MustHaveHappenedOnceOrMore();\nA.CallTo(() =&gt; foo.Bar()).MustHaveHappenedOnceOrLess();\nA.CallTo(() =&gt; foo.Bar()).MustHaveHappenedTwiceExactly();\nA.CallTo(() =&gt; foo.Bar()).MustHaveHappenedTwiceOrMore();\nA.CallTo(() =&gt; foo.Bar()).MustHaveHappenedTwiceOrLess();\nA.CallTo(() =&gt; foo.Bar()).MustHaveHappened(4, Times.Exactly);\nA.CallTo(() =&gt; foo.Bar()).MustHaveHappened(6, Times.OrMore);\nA.CallTo(() =&gt; foo.Bar()).MustHaveHappened(7, Times.OrLess);\nA.CallTo(() =&gt; foo.Bar()).MustHaveHappenedANumberOfTimesMatching(n =&gt; n % 2 == 0);\n</code></pre>"},{"location":"assertion/#asserting-calls-made-with-mutable-arguments","title":"Asserting Calls Made with Mutable Arguments","text":"<p>When FakeItEasy records a method (or property) call, it remembers which objects were used as argument, but does not take a snapshot of the objects' state. This means that if an object is changed after being used as an argument, but before argument constraints are checked, expected matches may not happen. For example,</p> <pre><code>var aList = new List&lt;int&gt; {1, 2, 3};\nA.CallTo(() =&gt; myFake.SaveList(A&lt;List&lt;int&gt;&gt;._))\n.Returns(true);\nmyFake.SaveList(aList);\naList.Add(4);\nA.CallTo(() =&gt; myFake.SaveList(A&lt;List&lt;int&gt;&gt;.That.IsThisSequence(1, 2, 3)))\n.MustHaveHappened();\n</code></pre> <p>The <code>MustHaveHappened</code> will fail, because at the time the <code>IsThisSequence</code> check is made, <code>aList</code> has 4 elements, not 3, and <code>IsThisSequence</code> only has the reference to <code>aList</code> to use in its check, not a deep copy or some other form of snapshot\u2014it has to work with the current state.</p> <p>If your test or production code must mutate call arguments between the time of the call and the assertion time, you must look for some other way to verify the call. Perhaps using <code>IsSameAs</code> will suffice, if the correct behavior of the System Under Test can otherwise be inferred. Or consider using Invokes to create a snapshot of the object and interrogate it later:</p> <pre><code>var aList = new List&lt;int&gt; {1, 2, 3};\nList&lt;int&gt; capturedList;\nA.CallTo(() =&gt; myFake.SaveList(A&lt;List&lt;int&gt;&gt;._))\n.Invokes((List&lt;int&gt; list) =&gt; capturedList = new List&lt;int&gt;(list))\n.Returns(true);\nmyFake.SaveList(aList);\naList.Add(4);\nAssert.That(capturedList, Is.EqualTo(new List&lt;int&gt; {1, 2, 3}));\n</code></pre>"},{"location":"assertion/#more-advanced-assertions","title":"More advanced assertions","text":"<p>If the built-in assertion API isn't sufficient, you can also examine the list of recorded calls directly, as described in Getting the list of calls made on a fake.</p>"},{"location":"assertion/#vbnet","title":"VB.NET","text":"<pre><code>' Functions and Subs can be asserted using their respective keywords\nA.CallTo(Function() foo.Bar()).MustHaveHappened()\nA.CallTo(Sub() foo.Baz(A(Of String).Ignored)).MustHaveHappened()\n</code></pre>"},{"location":"assigning-out-and-ref-parameters/","title":"Assigning out and ref parameters","text":"<p>Sometimes methods have <code>out</code> or <code>ref</code> parameters that need to be filled in when the faked method is called. Use <code>AssignsOutAndRefParameters</code>:</p> <pre><code>A.CallTo(() =&gt; aFake.AMethod(anInt, ref aRef, out anOut))\n.Returns(true)\n.AssignsOutAndRefParameters(\"new aRef value\", \"new anOut value\");\n</code></pre> <p><code>AssignsOutAndRefParameters</code> takes a <code>params object[]</code>, with one element (in order) for each of the <code>out</code> and <code>ref</code> parameters in the call being faked - the other parameters are omitted.</p> <p>While assigning <code>out</code> and <code>ref</code> parameters, the <code>Returns</code> method (or some variant) is often used to specify the return value for a non-void method - <code>AssignsOutAndRefParameters</code> does not do this on its own. If <code>AssignsOutAndRefParameters</code> is used without a <code>Returns</code>, the return value will be a Dummy. When both <code>Returns</code> and <code>AssignsOutAndRefParameters</code> are used, <code>Returns</code> must be specified first.</p>"},{"location":"assigning-out-and-ref-parameters/#assigning-values-calculated-at-call-time","title":"Assigning Values Calculated at Call Time","text":"<p>When <code>out</code> or <code>ref</code> parameter values aren't known until the method is called, <code>AssignsOutAndRefParametersLazily</code> can be used.</p> <pre><code>string theValue;\nA.CallTo(() =&gt; aFake.AMethod(anInt, ref aRef, out anOut))\n.Returns(true)\n.AssignsOutAndRefParametersLazily((int someInt, string someRef, string someOut) =&gt;\nnew[] { \"new aRef value: \" + someInt, \"new anOut value\" });\n</code></pre> <p>As shown above, the inputs to the method may be used to calculate the values to assign. Convenient overloads exist for methods of up to 8 parameters.</p> <p>The type of the <code>Func</code> sent to <code>AssignsOutAndRefParametersLazily</code> isn't checked at compile time, but any type mismatch will trigger a helpful error message.</p> <p>If more advanced decision-making is required, or the method has more than 8 parameters, the convenience methods won't work. Use the variant that takes an <code>IFakeObjectCall</code> instead:</p> <p><pre><code>string theValue;\nA.CallTo(() =&gt; aFake.AMethod(anInt, ref aRef, out anOut))\n.Returns(true)\n.AssignsOutAndRefParametersLazily(call =&gt; CalculateValuesFrom(call));\n</code></pre> The <code>IFakeObjectCall</code> object provides access to</p> <ul> <li>information about the <code>Method</code> being called, as a <code>MethodInfo</code>,</li> <li>the <code>Arguments</code>, accessed by position or name, and</li> <li>the original <code>FakedObject</code></li> </ul>"},{"location":"assigning-out-and-ref-parameters/#implicitly-assigning-out-parameter-values","title":"Implicitly Assigning <code>out</code> Parameter Values","text":"<p>Any <code>Expression</code>-based <code>A.CallTo</code> configuration that's made on a method that has an <code>out</code> parameter will cause the value of the variable used in the <code>A.CallTo</code> to be assigned to the <code>out</code> parameter when the method is actually called. For example:</p> <pre><code>string configurationValue = \"lollipop\";\nA.CallTo(() =&gt; aFakeDictionary.TryGetValue(theKey, out configurationValue))\n.Returns(true); string fetchedValue;\naFakeDictionary.TryGetValue(theKey, out fetchedValue);\n// fetchedValue is now \"lollipop\";\n</code></pre> <p>If this behavior is not desired, <code>AssignsOutAndRefParameters</code> (or <code>\u2026Lazily</code>) can be used to provide different behavior.</p>"},{"location":"bootstrapper/","title":"Bootstrapper","text":"<p>Most of FakeItEasy's functionality is directly triggered by client code: creating a fake, configuring a call and making assertions about calls are all explicitly invoked and are controllable by various input parameters.</p> <p>Some behavior is triggered implicitly. FakeItEasy initializes itself when its classes are first accessed. The Bootstrapper allows users to customize the initialization process.</p>"},{"location":"bootstrapper/#what-does-the-bootstrapper-do","title":"What does the Bootstrapper do?","text":"<p>At present, the Bootstrapper provides only one service:</p> <ul> <li><code>GetAssemblyFileNamesToScanForExtensions</code> provides a list of   absolute paths to assemblies that should be   scanned for extension points.   The default behavior is to return an empty list.</li> </ul>"},{"location":"bootstrapper/#how-can-the-behavior-be-changed","title":"How can the behavior be changed?","text":"<p>Provide an alternative bootstrapper class and ensure that it is loaded in the current AppDomain before FakeItEasy is initialized (often this means just including it in your test assembly).</p> <p>The best way to provide an alternative implementation is to extend FakeItEasy.DefaultBootstrapper. This class defines the default FakeItEasy setup behavior, so using it as a base allows clients to change only those aspects of the initialization that need to be customized.</p>"},{"location":"bootstrapper/#an-example-returning-a-specific-extra-assembly-scan-for-extensions","title":"An example: returning a specific extra assembly scan for extensions","text":"<p>Most often, FakeItEasy extension points will be defined in assemblies that are already loaded at the time that FakeItEasy is used. In some cases, extensions may reside in assemblies that are not (yet) loaded. Perhaps the extensions are distributed in a shared assembly that does not need to be referenced by any other code. The following bootstrapper can be used to force an additional assembly to be scanned for extension points.</p> <pre><code>public class ScanAnExternalAssemblyBootstrapper : FakeItEasy.DefaultBootstrapper\n{\npublic override IEnumerable&lt;string&gt; GetAssemblyFileNamesToScanForExtensions()\n{\nreturn new [] { @\"c:\\full\\path\\to\\another\\assembly.dll\" };\n}\n}\n</code></pre>"},{"location":"bootstrapper/#how-does-fakeiteasy-find-alternative-bootstrappers","title":"How does FakeItEasy find alternative bootstrappers?","text":"<p>Just before the first Bootstrapper function needs to be accessed, FakeItEasy checks all the assemblies currently loaded in the AppDomain. Each assembly is examined for exported types that implement <code>FakeItEasy.IBootstrapper</code>. The first such type that is not <code>FakeItEasy.DefaultBootstrapper</code> is instantiated and used. If no such type is found, then <code>FakeItEasy.DefaultBootstrapper</code> is used.</p> <p>Note that there is no warning provided if FakeItEasy finds more than one custom bootstrapper implementation. One will be chosen non-deterministically.</p>"},{"location":"calling-base-methods/","title":"Calling base methods","text":"<p>The <code>CallsBaseMethod</code> configuration method can be used to make a method execute the implementation of the faked class:</p> <pre><code>A.CallTo(() =&gt; fakeShop.SellSmarties())\n.CallsBaseMethod();\n</code></pre> <p>Configuring a method to call its base method only makes sense if the method is actually implemented, so this technique cannot be used on an abstract class method or on any method from a faked interface\u2014a faked abstract method told to call its base method will throw a <code>NotImplementedException</code>.</p>"},{"location":"calling-base-methods/#configuring-all-methods-at-once","title":"Configuring all methods at once","text":"<p>Perhaps you want to have all or nearly all of a fake's (fakeable) methods defer to the original implementation. Rather than using <code>CallsBaseMethod</code> a dozen times, the fake creation option <code>CallsBaseMethods</code> can do all the work at once:</p> <pre><code>var fakeShop = A.Fake&lt;CandyShop&gt;(options =&gt; options.CallsBaseMethods());\n</code></pre> <p>And then selectively override some of them</p> <pre><code>A.CallTo(() =&gt; fakeShop.SellRockets()).Throws&lt;Exception&gt;();\n</code></pre>"},{"location":"calling-wrapped-methods/","title":"Calling wrapped methods","text":"<p>By default, calls to a wrapping fake that have not been explicitly configured will be forwarded to the wrapped object. However, if this behavior has been overridden by another configuration, or if you need to invoke a callback before calling the wrapped method, you can explicitly configure the call to be forwarded to the wrapped object with the <code>CallsWrappedMethod</code> configuration method.</p> <pre><code>var realShop = new CandyShop();\nvar fakeShop = A.Fake&lt;ICandyShop&gt;(o =&gt; o.Wrapping(realShop));\nA.CallTo(() =&gt; fakeShop.SellSmarties())\n.Invokes(() =&gt; Console.WriteLine(\"Selling smarties!\"))\n.CallsWrappedMethod();\n</code></pre>"},{"location":"capturing-arguments/","title":"Capturing arguments","text":"<p>Often tests will make assertions against the calls made to a fake object to verify the behavior of the system under test, but you can also capture arguments supplied in a call to a fake object and examine the values later.</p>"},{"location":"capturing-arguments/#simple-capture","title":"Simple capture","text":"<p>Take this contrived example:</p> \"production code\"<pre><code>public interface IListLogger\n{\nvoid Log(string message, IEnumerable&lt;int&gt; list);\n}\ninternal sealed class Calculator(IListLogger logger)\n{\npublic int Add(IList&lt;int&gt; operands)\n{\nlogger.Log(\"about to add\", operands);\nreturn operands.Sum();\n}\npublic int Square(int input)\n{\nlogger.Log(\"about to square\", [input]);\nreturn input * input;\n}\n}\n</code></pre> <p>Suppose we want to make sure that we send correct messages to the logger. We can record the first argument to each <code>Log</code> call in a variable of type <code>Captured</code> and verify the values in the \"assert\" phase of the test.</p> simple capture<pre><code>// Arrange\nvar capturedMessage = A.Captured&lt;string&gt;();\nvar logger = A.Fake&lt;IListLogger&gt;();\nA.CallTo(() =&gt; logger.Log(\ncapturedMessage._,\nAn&lt;IEnumerable&lt;int&gt;&gt;._))\n.DoesNothing();\nvar calculator = new Calculator(logger);\n// Act\ncalculator.Add([1, 2, 3, 4]);\ncalculator.Square(7);\n// Assert\ncapturedMessage.Values.Should().Equal(\n\"about to add\",\n\"about to square\");\n// Or if you only care about the last value:\ncapturedMessage.GetLastValue().Should().Be(\n\"about to square\");\n</code></pre> <p>This is a fairly standard test with fakes, except we:</p> <ul> <li>create a <code>Captured</code> object to store received argument values</li> <li>use the <code>Captured</code> object's <code>_</code> member to configure the call to capture any values for that argument   (this is analogous to the <code>A&lt;T&gt;._</code> member, and just like it, there is a matching <code>Ignored</code> member in   case you prefer that name)</li> <li>specify that the method will do nothing.   As with any attempt to configure a fake object's behavior, it's the final   action that completes the <code>A.CallTo</code> sequence. Without it, there's no change to the fake object's   behavior, and no values will be captured on calls to the method. You don't need to pair <code>DoesNothing</code> with   configuration that uses a capturing argument: you could return values, throw exceptions, or whatever;   it was just appropriate here for a method that returns nothing.</li> <li>use <code>Values</code> to access all the captured values so they can be asserted</li> <li>(alternative flow) use <code>GetLastValue</code> to access the most recent captured value so it can be asserted.   This will throw a <code>FakeItEasy.ExpectationException</code> if no values have been captured.</li> </ul> Values are only captured if the call matches the configuration <p>When a call configuration intends to capture one or more arguments, the argument values are only captured if this specific call configuration is triggered. If an incoming call does not match that configured for the method or property, no arguments are captured.</p>"},{"location":"capturing-arguments/#capturing-and-constraining-at-the-same-time","title":"Capturing and constraining at the same time","text":"<p>Even though you can interrogate captured values after the fact, you may want to configure fake behavior to take effect only when incoming arguments meet a constraint. As you might have guessed based on the references to <code>_</code> and <code>Ignored</code> above, you can do this using a <code>That</code> method just like the one supplied by the <code>A&lt;T&gt;</code> argument constraints:</p> constrained capture<pre><code>// Arrange\nvar capturedMessage = A.Captured&lt;string&gt;();\nvar logger = A.Fake&lt;IListLogger&gt;();\nA.CallTo(() =&gt; logger.Log(\ncapturedMessage.That.Contains(\"add\"),\nAn&lt;IEnumerable&lt;int&gt;&gt;._))\n.DoesNothing();\nvar calculator = new Calculator(logger);\n// Act\ncalculator.Add([1, 2, 3, 4]);\ncalculator.Square(7);\ncalculator.Add([8, 9]);\n// Assert\ncapturedMessage.Values.Should().Equal(\n\"about to add\",\n\"about to add\");\n</code></pre>"},{"location":"capturing-arguments/#capturing-mutable-arguments","title":"Capturing mutable arguments","text":""},{"location":"capturing-arguments/#the-challenge","title":"The challenge","text":"<p>Argument capture is shallow; there's no copying of object state. If a reference-based argument (e.g. a class instance, not a struct) is captured and subsequently modified by the test or production code, the \"assert\" phase of the test will see the updated state.</p> capturing mutating values<pre><code>// Arrange\nvar capturedOperands = A.Captured&lt;IEnumerable&lt;int&gt;&gt;();\nvar logger = A.Fake&lt;IListLogger&gt;();\nA.CallTo(() =&gt; logger.Log(\n\"about to add\",\ncapturedOperands._))\n.DoesNothing();\nvar calculator = new Calculator(logger);\n// Act\nList&lt;int&gt; operands = [1, 2, 3, 4];\ncalculator.Add(operands); // capturedOperands captures operands\noperands.RemoveAt(0);\ncalculator.Add(operands); // captures operands again - same instance\n// Assert\n// passes:\ncapturedOperands.Values[1].Should().Equal(2, 3, 4);\n// fails - operands contains only 2, 3, and 4:\ncapturedOperands.Values[0].Should().Equal(1, 2, 3, 4);\n</code></pre> <p>Here a single list instance is passed to the production code twice, but an element is removed between the calls. The <code>Captured</code> object captures a reference to the list each time, but does not preserve the internals of the list. So by the time the <code>Values</code> are examined, the list has had its first element removed, and this is reflected in the failing assertion.</p> <p>It's the same effect as running</p> <pre><code>List&lt;int&gt; list = [1, 2, 3, 4];\nvar a = list;\nlist.RemoveAt(0);\nvar b = list;\n// both a and b point to a list with elements { 2, 3, 4 }\n</code></pre>"},{"location":"capturing-arguments/#capturing-frozen-state","title":"Capturing frozen state","text":"<p><code>Captured</code> objects can be created with a transforming function (or \"freezer\") that runs on the argument value before saving it away, thus insulating the captured values from subsequent mutations.</p> freezing state of captured values<pre><code>// Arrange\nvar capturedOperands =\nA.Captured&lt;IEnumerable&lt;int&gt;&gt;().FrozenBy(l =&gt; l.ToList());\nvar logger = A.Fake&lt;IListLogger&gt;();\nA.CallTo(() =&gt; logger.Log(\n\"about to add\",\ncapturedOperands._))\n.DoesNothing();\nvar calculator = new Calculator(logger);\n// Act\nList&lt;int&gt; operands = [1, 2, 3, 4];\ncalculator.Add(operands); // capturedOperands captures copy of operands\noperands.RemoveAt(0);\ncalculator.Add(operands); // capturedOperands captures copy of operands\n// Assert\n// both pass:\ncapturedOperands.Values[1].Should().Equal(2, 3, 4);\ncapturedOperands.Values[0].Should().Equal(1, 2, 3, 4);\n</code></pre> <p>You can even transform values into a different type:</p> freezing state of captured values as new type<pre><code>// Arrange\nvar capturedOperands =\nA.Captured&lt;IEnumerable&lt;int&gt;&gt;().FrozenBy(l =&gt; string.Join(\" + \", l));\nvar logger = A.Fake&lt;IListLogger&gt;();\nA.CallTo(() =&gt; logger.Log(\n\"about to add\",\ncapturedOperands._))\n.DoesNothing();\nvar calculator = new Calculator(logger);\n// Act\nList&lt;int&gt; operands = [1, 2, 3, 4];\ncalculator.Add(operands); // capturedOperands captures transformed operands\noperands.RemoveAt(0);\ncalculator.Add(operands); // capturedOperands captures transformed operands\n// Assert\ncapturedOperands.Values[1].Should().Be(\"2 + 3 + 4\");\ncapturedOperands.Values[0].Should().Be(\"1 + 2 + 3 + 4\");\n</code></pre> <p>In this case we supply an updated freezer function as well as the <code>Captured</code> typeparams for both the argument value and the captured value types.</p>"},{"location":"changing-behavior-between-calls/","title":"Changing behavior between calls","text":""},{"location":"changing-behavior-between-calls/#limited-call-specifications","title":"Limited call specifications","text":"<p>When specifying return values or configuring exceptions to be thrown and so on, it's possible to define the number of times the action can occur. By default, omitting the number of repetitions is the same as saying \"forever\", so after specifying <code>A.CallTo(() =&gt;fakeShop.Address).Returns(\"123 Fake Street\")</code>, <code>fakeShop.Address</code> will return the same value every time it's called. Forever.</p> <p>This can be changed, though: <pre><code>A.CallTo(() =&gt; fakeShop.Address).Returns(\"123 Fake Street\").Once();\nA.CallTo(() =&gt; fakeShop.Address).Returns(\"123 Fake Street\").Twice();\nA.CallTo(() =&gt; fakeShop.Address).Returns(\"123 Fake Street\").NumberOfTimes(17);\n</code></pre></p> <p>This could be useful if you want to allow a limited number of calls on a strict fake, but there's a more useful application.</p>"},{"location":"changing-behavior-between-calls/#specifying-different-behaviors-for-successive-calls","title":"Specifying different behaviors for successive calls","text":"<p>In some cases, you might want to specify different behaviors for successive calls to the same method. For instance, in order to test the System Under Test's retry logic, a Fake service could be configured to fail once and then function properly thereafter. This can be done by chaining behaviors like this:</p> <pre><code>// Configure the method to throw an exception once, then succeed forever\nA.CallTo(() =&gt; fakeService.DoSomething())\n.Throws&lt;Exception&gt;().Once()\n.Then\n.Returns(\"SUCCESS\");\n</code></pre> <p>Note that you can only use <code>Then</code> after specifying that some behavior should only occur a limited number of times.</p>"},{"location":"changing-behavior-between-calls/#overriding-the-behavior-for-a-call","title":"Overriding the behavior for a call","text":"<p>Call specifications act kind of like a stack - they're pushed on the Fake and then popped off once the number of repetitions defined for a call have been exhausted.</p> <p>Thus, it's possible to have a call to a Fake act one way, and then another. For instance, the same effect as the previous sample can be achieved by overriding the behavior of the fake:</p> <pre><code>// set up an action that can run forever, unless superseded\nA.CallTo(() =&gt; fakeService.DoSomething()).Returns(\"SUCCESS\");\n// set up a one-time exception which will be used for the first call\nA.CallTo(() =&gt; fakeService.DoSomething()).Throws&lt;Exception&gt;().Once();\n</code></pre> <p>This can be useful when you are unable to use <code>Then</code> to specify a different behavior for successive calls. For example, when you have a fake with a default behavior (configured in a test <code>Setup</code> method or a <code>FakeOptionsBuilder</code>), and you need to override this behavior for a specific test.</p>"},{"location":"creating-fakes/","title":"Creating Fakes","text":""},{"location":"creating-fakes/#natural-fakes","title":"Natural fakes","text":"<p>The common way to create a fake object is by using the <code>A.Fake</code> syntax, for example:</p> <p><pre><code>var foo = A.Fake&lt;IFoo&gt;();\n</code></pre> This will return a faked object that is an actual instance of the type specified (<code>IFoo</code> in this case).</p> <p>You can create a fake delegate with the same syntax: <pre><code>var func = A.Fake&lt;Func&lt;string, int&gt;&gt;();\n</code></pre></p> <p>You can also create a collection of fakes by writing: <pre><code>var foos = A.CollectionOfFake&lt;Foo&gt;(10);\n</code></pre></p> <p>For cases where the type to fake isn't statically known, non-generic methods are also available. These are usually only required when writing extensions for FakeItEasy, so they live in the <code>FakeItEasy.Sdk</code> namespace: <pre><code>using FakeItEasy.Sdk;\n...\nvar type = GetTypeOfFake();\nobject fake = Create.Fake(type);\nIList&lt;object&gt; fakes = Create.CollectionOfFake(type, 10);\n</code></pre></p>"},{"location":"creating-fakes/#explicit-creation-options","title":"Explicit Creation Options","text":"<p>When creating fakes you can, through a fluent interface, specify options for how the fake should be created, depending on the type of fake being made:</p> Option Applies to Specify arguments for the constructor of the faked type non-delegates Specify additional interfaces that the fake should implement non-delegates Assign additional custom attributes to the faked type non-delegates Cause a fake to have strict mocking semantics any fake Configure all of a fake's methods to use their original implementation classes Create a fake that wraps another object any fake Create a named fake any fake <p>Examples:</p> <pre><code>// Specifying arguments for constructor using an expression. This is refactoring friendly!\n// Since the constructor call seen here is an expression, it is not invoked. Instead, the\n// constructor arguments will be extracted from the expression and provided to\n// the fake class's constructor. (Of course the fake class, being a subclass of `FooClass`,\n// ultimately invokes `FooClass`'s constructor with these arguments.)\nvar foo = A.Fake&lt;FooClass&gt;(x =&gt; x.WithArgumentsForConstructor(() =&gt; new FooClass(\"foo\", \"bar\")));\n// Specifying arguments for constructor using IEnumerable&lt;object&gt;.\nvar foo = A.Fake&lt;FooClass&gt;(x =&gt; x.WithArgumentsForConstructor(new object[] { \"foo\", \"bar\" }));\n// Specifying additional interfaces to be implemented. Among other uses,\n// this can help when a fake skips members because they have been\n// explicitly implemented on the class being faked.\nvar foo = A.Fake&lt;FooClass&gt;(x =&gt; x.Implements(typeof(IFoo)));\n// or\nvar foo = A.Fake&lt;FooClass&gt;(x =&gt; x.Implements&lt;IFoo&gt;());\n// Assigning custom attributes to the faked type.\n// foo's type should have \"FooAttribute\"\nvar foo = A.Fake&lt;IFoo&gt;(x =&gt; x.WithAttributes(() =&gt; new FooAttribute()));\n// Create wrapper - unconfigured calls will be forwarded to wrapped\nvar wrapped = new FooClass(\"foo\", \"bar\");\nvar foo = A.Fake&lt;IFoo&gt;(x =&gt; x.Wrapping(wrapped));\n// Create a named fake, for easier identification in error messages and using ToString()\n// Note that for a faked delegate, ToString() won't return the name, because only the Invoke\n// method of a delegate can be configured.\nvar foo = A.Fake&lt;IFoo&gt;(x =&gt; x.Named(\"Foo #1\"));\n</code></pre>"},{"location":"creating-fakes/#implicit-creation-options","title":"Implicit Creation Options","text":"<p>Implicit creation options are available, equivalent in power to the explicit creation options mentioned above.</p>"},{"location":"creating-fakes/#unnatural-fakes","title":"Unnatural fakes","text":"<p>For those accustomed to Moq there is an alternative way of creating fakes through the <code>new Fake&lt;T&gt;</code> syntax. The fake provides a fluent interface for configuring the faked object:</p> <pre><code>var fake = new Fake&lt;IFoo&gt;();\nfake.CallsTo(x =&gt; x.Bar(\"some argument\")).Returns(\"some return value\");\nvar foo = fake.FakeObject;\n</code></pre> <p>For an alternative look at migrating from Moq to FakeItEasy, see Daniel Marbach's blog post that talks about Migration from Moq to FakeItEasy with Resharper Search Patterns.</p>"},{"location":"custom-argument-equality/","title":"Custom argument equality","text":""},{"location":"custom-argument-equality/#default-behavior-when-comparing-argument-values","title":"Default behavior when comparing argument values","text":"<p>By default, FakeItEasy compares argument values using <code>Object.Equals</code>. For instance, consider this call configuration:</p> <pre><code>A.CallTo(() =&gt; fake.DoSomething(\"hello\")).Returns(42);\n</code></pre> <p>When comparing the argument value from the actual call with the configured value <code>\"hello\"</code>, the values are compared with the default comparison rules (using <code>String.Equals</code> in this case).</p> <p>In most cases, that's what you want, but there are scenarios where it can be inconvenient. For example, you might want to compare instances based on the values of their properties, but by default the objects are compared using reference equality. If you don't own the type, you can't override <code>Equals</code> to implement the desired behavior. So you end up having to compare the properties explicitly in an argument constraint:</p> <pre><code>Foo expectedFoo = ...;\nA.CallTo(() =&gt;\nfake.DoSomethingElse(A&lt;Foo&gt;.That.Matches(foo =&gt; foo.Bar == expectedFoo.Bar)))\n.Returns(42);\n</code></pre> <p>This is quite verbose, and not very readable. Ideally you would write it like this:</p> <pre><code>Foo expectedFoo = ...;\nA.CallTo(() =&gt; fake.DoSomethingElse(expectedFoo)).Returns(42);\n</code></pre> <p>And it would just do the right thing.</p> <p>FakeItEasy offers a way to override the default behavior by providing a custom argument equality comparer.</p>"},{"location":"custom-argument-equality/#writing-a-custom-argument-equality-comparer","title":"Writing a custom argument equality comparer","text":"<p>Just define a class that inherits <code>ArgumentEqualityComparer&lt;T&gt;</code>, and override the <code>AreEqual</code> method:</p> <pre><code>public class FooComparer : ArgumentEqualityComparer&lt;Foo&gt;\n{\nprotected override bool AreEqual(Foo expectedValue, Foo argumentValue)\n{\nreturn expectedValue.Bar == argumentValue.Bar;\n}\n}\n</code></pre> <p>FakeItEasy will automatically discover this class and use it to compare instances of <code>Foo</code>.</p>"},{"location":"custom-argument-equality/#how-it-works","title":"How it works","text":"<p>FakeItEasy uses classes that implement the following interface to compare argument values:</p> <pre><code>public interface IArgumentEqualityComparer\n{\nbool CanCompare(Type type);\nbool AreEqual(object expectedValue, object argumentValue);\nPriority Priority { get; }\n}\n</code></pre> <p>When FakeItEasy needs to compare a non-null argument value with a non-null expected value, it looks at all known <code>IArgumentEqualityComparer</code> implementations for which <code>CanCompare</code> returns true for the type of the expected value. If multiple implementations match, the one with the highest <code>Priority</code> is used.</p> <p>If all that's needed is an Argument Equality Comparer that specifies how to compare two instances of a specific type, extending <code>abstract class ArgumentEqualityComparer&lt;T&gt;: IArgumentEqualityComparer</code> is preferred. It provides default implementations of <code>Priority</code> and <code>CanCompare</code> (although they can be overridden if needed).</p> <p>However, if you want to provide custom equality comparison for a variety of types, you may prefer to implement <code>IArgumentEqualityComparer</code> directly. For example, if you wanted all types in a specific namespace to be compared by their string representation, you might write something like this:</p> <pre><code>class ToStringArgumentEqualityComparer : IArgumentEqualityComparer\n{\npublic bool CanCompare(Type type) =&gt; type.Namespace == \"MySpecialNamespace\";\npublic bool AreEqual(object expectedValue, object argumentValue)\n{\nreturn expectedValue.ToString() == argumentValue.ToString();\n}\npublic Priority Priority =&gt; Priority.Default;\n}\n</code></pre>"},{"location":"custom-argument-equality/#how-does-fakeiteasy-find-argument-equality-comparers","title":"How does FakeItEasy find Argument Equality Comparers?","text":"<p>On initialization, FakeItEasy looks for Discoverable Extension Points, including Argument Equality Comparers.</p>"},{"location":"custom-dummy-creation/","title":"Custom Dummy Creation","text":"<p>FakeItEasy has built-in Dummy creation rules that provide usable non-null values to be used in tests. However, if the default dummy creation behavior isn't adequate, you can provide your own. Here's an example:</p> <pre><code>class DummyBookFactory : DummyFactory&lt;Book&gt;\n{\nprotected override Book Create()\n{\nreturn new Book { Title = \"Some Book\", PublishedOn = new DateTime(2000, 1, 1) };\n}\n}\n</code></pre>"},{"location":"custom-dummy-creation/#how-it-works","title":"How it works","text":"<p>FakeItEasy uses classes that implement the following interface to create Dummies:</p> <pre><code>public interface IDummyFactory\n{\nbool CanCreate(Type type);\nobject Create(Type type);\nPriority Priority { get; }\n}\n</code></pre> <p>When FakeItEasy tries to create a Dummy, it looks at all known <code>IDummyFactory</code> implementations for which <code>CanCreate</code> returns <code>true</code>. If multiple implementations match, the one with the highest <code>Priority</code>is used.</p> <p>If all that's needed is a Dummy Factory that creates a single, explicit type, extending <code>abstract class DummyFactory&lt;T&gt;: IDummyFactory</code> is preferred. It provides default implementations of <code>Priority</code> and <code>CanCreate</code> (although they can be overridden if needed).</p> <p>However, if you want to provide Dummies for a variety of types, you may prefer to extend <code>IDummyFactory</code> directly. For example, if you wanted all Dummy <code>IEnumerable&lt;T&gt;</code>s to be <code>SortedSet&lt;T&gt;</code>s, you might write something like this:</p> <pre><code>class DummyEnumerableFactory: IDummyFactory\n{\npublic bool CanCreate(Type type)\n{\nif (type.IsGenericType)\n{\nvar enumerableContentType = type.GetGenericArguments()[0];\nvar enumerableTypeDefinition = typeof (IEnumerable&lt;&gt;).MakeGenericType(enumerableContentType);\nreturn enumerableTypeDefinition.IsAssignableFrom(type);\n}\nreturn false;\n}\npublic object Create(Type type)\n{\nvar enumerableContentType = type.GetGenericArguments()[0];\nvar enumerableType = typeof (SortedSet&lt;&gt;).MakeGenericType(enumerableContentType);\nreturn enumerableType.GetConstructor(new Type[0]).Invoke(null);\n}\npublic Priority Priority\n{\nget { return Priority.Default; }\n}\n}\n</code></pre>"},{"location":"custom-dummy-creation/#how-does-fakeiteasy-find-the-dummy-factories","title":"How does FakeItEasy find the Dummy Factories?","text":"<p>On initialization, FakeItEasy looks for Discoverable Extension Points, including Dummy Factories.</p>"},{"location":"default-fake-behavior/","title":"Default fake behavior","text":"<p>Fake objects come with useful default behavior as soon as they are created. Knowing the default behavior can make the fakes easier to work with and can lead to more concise tests.</p>"},{"location":"default-fake-behavior/#non-overrideable-members-cannot-be-faked","title":"Non-overrideable members cannot be faked","text":"<p>Methods and properties can only be faked if they are declared on a faked interface, or are declared abstract or virtual on a faked class. If none of these conditions hold, then a member cannot be faked, just as it could not be overridden in a derived class.</p> <p>When such a member is invoked on the fake, the original behavior will be invoked.</p>"},{"location":"default-fake-behavior/#overrideable-members-are-faked","title":"Overrideable members are faked","text":"<p>When a method or property is declared on a faked interface, or is declared as abstract or virtual on a faked class, and the member is invoked on the fake, no action will be taken by the fake. It is as if the body of the member were empty. If the member has a return type (or is a get property), the return value will depend on the type <code>T</code> of the member:</p> <ul> <li>If <code>T</code> can be made into a Dummy, then a Dummy <code>T</code> will   be returned. Note that this may be a Fake or an instance of a   concrete, pre-existing type;</li> <li>otherwise, <code>default(T)</code> will be returned.</li> </ul>"},{"location":"default-fake-behavior/#readwrite-properties","title":"Read/write properties","text":"<p>By default, any overrideable property that has both a <code>set</code> and <code>get</code> accessor, and that has not been explicitly configured to behave otherwise, behaves like you might expect. Setting a value and then getting the value returns the value that was set.</p> <pre><code>var fakeShop = A.Fake&lt;ICandyShop&gt;();\nfakeShop.Address = \"123 Fake Street\";\nSystem.Console.Out.Write(fakeShop.Address);\n// prints \"123 Fake Street\"\n</code></pre> <p>This behavior can be used to</p> <ul> <li>supply values for the system under test to use (via the getter) or to</li> <li>verify that the system under test performed the <code>set</code> action on the Fake</li> </ul>"},{"location":"default-fake-behavior/#object-members","title":"Object members","text":"<p>Virtual methods inherited from <code>System.Object</code> are faked with a special default behavior:</p> <ul> <li><code>Equals</code> uses reference equality: it returns <code>true</code> if the argument is the fake   itself, <code>false</code> for any other argument.</li> <li><code>GetHashCode</code> returns a hashcode consistent with the behavior of <code>Equals</code>.</li> <li><code>ToString</code> returns a string of the form \"Faked &lt;type of fake&gt;\"</li> </ul> <p>This behavior applies to all fakes, including fakes of types that override these methods. Like any other method, the behavior can be explicitly configured.</p>"},{"location":"default-fake-behavior/#cancellation-tokens","title":"Cancellation tokens","text":"<p>When a faked method that accepts a <code>CancellationToken</code> receives a canceled token (i.e. with <code>IsCancellationRequested</code> set to <code>true</code>), it will either:</p> <ul> <li>return a canceled task, if it is asynchronous (i.e. if it returns a <code>Task</code>,   <code>Task&lt;T&gt;</code>, <code>ValueTask</code> or <code>ValueTask&lt;T&gt;</code>);</li> <li>throw an <code>OperationCanceledException</code>, if it is synchronous.</li> </ul>"},{"location":"default-fake-behavior/#examples","title":"Examples","text":"<p>Suppose we have the following interface definition</p> <pre><code>public interface Interface\n{\nbool BooleanFunction();\nint IntProperty { get; set; }\nstring StringFunction();\nFakeableClass FakeableClassFunction();\nUnfakeableClass UnfakeableClassProperty { get; set; }\nStruct StructFunction();\n}\n</code></pre> <p>Then the following test will pass</p> <pre><code>public void Members_should_return_empty_string_default_or_fake_another_fake()\n{\nvar fakeLibrary = A.Fake&lt;Interface&gt;();\nAssert.AreEqual(default(bool), fakeLibrary.BooleanFunction());\nAssert.AreEqual(default(int), fakeLibrary.IntProperty);\nAssert.AreEqual(typeof(string), fakeLibrary.StringFunction().GetType());\nAssert.AreEqual(string.Empty, fakeLibrary.StringFunction());\nAssert.IsInstanceOfType(fakeLibrary.FakeableClassFunction(), typeof(FakeableClass));\nAssert.AreEqual(\"FakeableClassProxy\",\nfakeLibrary.FakeableClassFunction().GetType().Name); // to show it's a fake\nAssert.IsNull(fakeLibrary.UnfakeableClassProperty);\nAssert.AreEqual(default(Struct), fakeLibrary.StructFunction());\n}\n</code></pre>"},{"location":"doing-nothing/","title":"Doing Nothing","text":"<p>Sometimes you want a call to be ignored. That can be configured like so: <pre><code>A.CallTo(() =&gt; aFake.SomeVoidMethodThatShouldDoNothing())\n.DoesNothing();\n</code></pre></p> <p>This is quite close to what a default Fake's unconfigured member will do, but there a few situations where you may need to make the <code>DoesNothing</code> call explicitly. Here are some examples:</p> <ul> <li>To allow a call to a member on a strict Fake, where an otherwise   unconfigured call will throw an exception.</li> <li>To change the behavior that an already-configured call is supposed to have.   For example, if a call is set to throw an exception, that can be   overridden. For more on this kind of thing, see how to   override the behavior for a call.</li> <li>To fulfill FakeItEasy's configuration API requirements by providing an action when applying    capturing arguments to a Fake's member. Aside from capturing, you may   not want to change the behavior of the member, but you have to use some action to complete the   chained calls that configure the method.</li> </ul> Only applies to members that return nothing <p>Note that <code>DoesNothing</code> is only applicable when configuring members that have a <code>void</code> return (or <code>Task</code>, which is the async equivalent of <code>void</code>). To override behavior on members that return values, you must instead configure a preferred return value.</p>"},{"location":"dummies/","title":"Dummies","text":"<p>A Dummy is an object that FakeItEasy can provide when an object of a certain type is required, but the actual behavior of the object is not important.</p>"},{"location":"dummies/#how-to-use-them-in-your-tests","title":"How to use them in your tests","text":"<p>Consider this example. Say that you want to test the following class:</p> <pre><code>public class Library\n{\npublic bool Checkout(Card patronCard, Book someBook);\n}\n</code></pre> <p>Maybe in one of your tests you want to invoke <code>Checkout</code> with an expired library card. The checkout should fail, regardless of the book being checked out\u2014only the status of the card matters. Instead of writing</p> <pre><code>library.Checkout(MakeExpiredCard(),\nnew Book { Title = \"The Ocean at the End of the Lane\" } );\n</code></pre> <p>You can write:</p> <pre><code>library.Checkout(MakeExpiredCard(), A.Dummy&lt;Book&gt;());\n</code></pre> <p>This signals that the actual value of the <code>Book</code> is really not important. The code is intention-revealing.</p> <p>You can also create a collection of dummies by writing:</p> <pre><code>A.CollectionOfDummy&lt;Book&gt;(10);\n</code></pre> <p>This will return an <code>IList</code> containing 10 dummy <code>Book</code> instances.</p> <p>For cases where the type of dummy isn't statically known, non-generic methods are also available. These are usually only required when writing extensions for FakeItEasy, so they live in the <code>FakeItEasy.Sdk</code> namespace: <pre><code>using FakeItEasy.Sdk;\n...\nvar type = GetTypeOfDummy();\nobject dummy = Create.Dummy(type);\nIList&lt;object&gt; dummies = Create.CollectionOfDummy(type, 10);\n</code></pre></p>"},{"location":"dummies/#how-fakeiteasy-uses-them","title":"How FakeItEasy uses them","text":"<p>When creating Fakes or Dummies of class types, FakeItEasy needs to invoke the classes' constructors. If the constructors take arguments, FakeItEasy needs to generate appropriate argument values. It uses Dummies.</p>"},{"location":"dummies/#how-are-the-dummies-made","title":"How are the Dummies made?","text":"<p>When FakeItEasy needs to access a Dummy of type <code>T</code>, it tries a number of approaches in turn, until one succeeds:</p> <ol> <li>If <code>T</code> is <code>void</code>, return <code>null</code>.</li> <li>If there's a user-supplied   dummy factory for <code>T</code>,   return whatever it makes.</li> <li>If <code>T</code> is <code>String</code>, return an empty string.</li> <li>If <code>T</code> is <code>Task</code> or <code>ValueTask</code>, the returned Dummy will be an actual <code>Task</code> or <code>ValueTask</code>    that is already completed.</li> <li>If <code>T</code> is <code>Task&lt;TResult&gt;</code> or <code>ValueTask&lt;TResult&gt;</code>, the returned Dummy will be an actual   <code>Task&lt;TResult&gt;</code> or <code>ValueTask&lt;TResult&gt;</code> that is already completed and whose <code>Result</code> is a   Dummy of type <code>TResult</code>, or a default <code>TResult</code> if no  Dummy can be made for <code>TResult</code>.</li> <li>If <code>T</code> is a <code>Lazy&lt;TValue&gt;</code> the returned Dummy will be an actual   <code>Lazy&lt;TValue&gt;</code> whose <code>Value</code> is a Dummy of type   <code>TValue</code>, or a default <code>TValue</code> if no Dummy can be made   for <code>TValue</code>.</li> <li>If <code>T</code> is a tuple type (<code>Tuple&lt;&gt;</code> or <code>ValueTuple&lt;&gt;</code>), the Dummy will be a tuple whose elements are dummies, or default values when dummies can't be made.</li> <li>If <code>T</code> is a value type, the Dummy will be the default value for that type (i.e. <code>new T()</code>).</li> <li>If <code>T</code> is fakeable, the Dummy will be a   Fake <code>T</code>.</li> <li>If nothing above matched, then <code>T</code> is a class. Loop over all its   public constructors in descending order of argument list length.   For each constructor, attempt to get Dummies to satisfy the argument   list. If the Dummies can be found, create an instance using that constructor,   supplying the Dummies as the argument list. If the argument list can't be satisfied,   then try the next constructor.</li> </ol> <p>If none of these strategies yield a viable Dummy, then FakeItEasy can't make a Dummy of type <code>T</code>.</p>"},{"location":"external-resources/","title":"External Resources","text":"<ul> <li>FakeItEasy courses on Pluralsight</li> <li>The \"fakeiteasy\" tag on StackOverflow</li> <li>Mocking HttpContext with FakeItEasy</li> <li>Migration from Moq to FakeItEasy with Resharper Search Patterns</li> </ul>"},{"location":"faking-async-methods/","title":"Faking async methods","text":"<p>The faking of <code>async</code> methods is fully supported in FakeItEasy.</p> <pre><code>public class Foo\n{\npublic virtual async Task&lt;string&gt; Bar()\n{\n// await something...\n}\n}\n</code></pre> <p>A call to a non-configured async method on a fake will return a Dummy <code>Task</code> or <code>Task&lt;T&gt;</code>, just as if it were any other method that returns a <code>Task</code> or <code>Task&lt;T&gt;</code>. For example:</p> <pre><code>var foo = A.Fake&lt;Foo&gt;();\nvar bar = await foo.Bar(); // will return immediately and return string.Empty\n</code></pre> <p>Of course, you can still configure calls to <code>async</code> methods as you would normally:</p> <pre><code>A.CallTo(() =&gt; foo.Bar()).Returns(Task.FromResult(\"bar\"));\n</code></pre> <p>There are also convenience overloads of <code>Returns</code> and <code>ReturnsLazily</code> that let you specify a value rather than a task, and configure the method to return a completed task whose result is the specified value:</p> <pre><code>A.CallTo(() =&gt; foo.Bar()).Returns(\"bar\");\n</code></pre> <p>These overloads of <code>Returns</code> and <code>ReturnsLazily</code> also exist for <code>ValueTask&lt;T&gt;</code>. If your test project targets a framework compatible with .NET Standard 2.1 or higher, they're built into FakeItEasy itself; otherwise, they're in a separate package: <code>FakeItEasy.Extensions.ValueTask</code>.</p>"},{"location":"faking-async-methods/#throwing-exceptions","title":"Throwing exceptions","text":"<p>To configure an async method to throw an exception, see Throwing exceptions from an async method.</p>"},{"location":"formatting-argument-values/","title":"Formatting Argument Values","text":"<p>FakeItEasy tries to provide helpful error messages when an Assertion isn't met. For example, when an expected call to a fake method isn't made, or when an unexpected call is made. Often these messages are adequate, but sometimes there's a need to improve upon them, which can be done by writing custom argument value formatters.</p>"},{"location":"formatting-argument-values/#fakeiteasys-default-formatter-behavior","title":"FakeItEasy's default formatter behavior","text":"<p>Unless custom formatters are provided, FakeItEasy formats argument values like so:</p> <ul> <li>the <code>null</code> value is formatted as <code>NULL</code>,</li> <li>the empty <code>string</code> is formatted as <code>string.Empty</code>,</li> <li>other <code>string</code> values are formatted as <code>\"the string value\"</code>, including the quotation marks, and</li> <li>any other value is formatted as its <code>ToString()</code> result</li> </ul> <p>There is no way to change FakeItEasy's behavior when formatting <code>null</code>, but the other behavior can be overridden by user-defined formatters.</p>"},{"location":"formatting-argument-values/#writing-a-custom-argument-value-formatter","title":"Writing a custom argument value formatter","text":"<p>Just define a class that extends <code>FakeItEasy.ArgumentValueFormatter&lt;T&gt;</code>. Here's a sample that formats argument values of type <code>Book</code>: <pre><code>class BookArgumentValueFormatter : ArgumentValueFormatter&lt;Book&gt;\n{\nprotected override string GetStringValue(Book argumentValue)\n{\nreturn string.Format(\"'{0}' published on {1:yyyy-MM-dd}\",\nargumentValue.Title, argumentValue.PublishedOn);\n}\n}\n</code></pre></p> <p>This would help FakeItEasy display this error message:</p> <pre>\nAssertion failed for the following call:\n  SampleTests.ILibrary.Checkout(&lt;Ignored&gt;)\nExpected to find it never but found it once among the calls:\n  1: SampleTests.ILibrary.Checkout(book: 'The Ocean at the End of the Lane', published on 2013-06-18)\n</pre> <p>which could make tracking down any failures a little easier.</p> <p>Compare to the original behavior:</p> <pre>\nAssertion failed for the following call:\n  SampleTests.ILibrary.Checkout(&lt;Ignored&gt;)\nExpected to find it never but found it once among the calls:\n  1: SampleTests.ILibrary.Checkout(book: SampleTests.Book)\n</pre> <p>In the original form of the message, the Book argument is just formatted using <code>Book.ToString()</code> because FakeItEasy doesn't know any better.</p>"},{"location":"formatting-argument-values/#how-it-works","title":"How it works","text":"<p>FakeItEasy uses classes that implement the following interface to format argument values:</p> <pre><code>public interface IArgumentValueFormatter\n{\nstring GetArgumentValueAsString(object argumentValue);\nType ForType { get; }\nPriority Priority { get; }\n}\n</code></pre> <p><code>GetArgumentValueAsString</code> does the work, transforming an argument into its formatted representation. <code>ForType</code> indicates what type of argument a formatter can format. <code>Priority</code> is discussed below.</p> <p>Above, we wrote a formatter in the preferred way, by extending <code>abstract class ArgumentValueFormatter&lt;T&gt;: IArgumentValueFormatter</code>. <code>ArgumentValueFormatter&lt;T&gt;</code> defines a <code>GetArgumentValueAsString</code> method that defers to <code>GetStringValue</code>, and its <code>ForType</code> method simply returns <code>T</code>. The default implementation of <code>Priority</code> returns <code>Priority.Default</code> (equivalent to value <code>0</code>), but this can be overridden.  It's possible to write a formatter from scratch, but there's no advantage to doing so over extending <code>ArgumentValueFormatter&lt;T&gt;</code>.</p> <p>It's possible to create formatters for any type, including concrete types, abstract types, and interfaces. Formatters defined for base types and interfaces will be used when formatting values whose types extend or implement the formatter's type.</p>"},{"location":"formatting-argument-values/#resolving-formatter-collisions","title":"Resolving formatter collisions","text":"<p>It's possible for a solution to contain multiple formatters that would apply to the same types of arguments. In fact, it's guaranteed to happen, since FakeItEasy itself defines a formatter that applies to <code>object</code>s and one that applies to <code>string</code>s. Any user-defined formatter will conflict with at least the built-in object formatter, and maybe others. When there is more than one candidate for formatting an argument, FakeItEasy picks the best one based on two factors:</p> <ul> <li>the distance between the argument's type (hereafter ArgType) and the type each formatter knows about (hereafter ForType), and</li> <li>the value of each formatter's <code>Priority</code> property</li> </ul>"},{"location":"formatting-argument-values/#lowest-distance","title":"Lowest distance","text":"<p>When an argument value needs to be formatted, FakeItEasy examines all known formatters whose ForType is in ArgType's inheritance tree, or whose ForType is an interface that ArgType implements. The distance between ForType and ArgType is calculated as follows:</p> <ul> <li>0 if ForType and ArgType are the same</li> <li>1 if ForType is an interface that ArgType implements</li> <li>2 if <code>ForType == ArgType.BaseType</code>, </li> <li>3 if <code>ForType == ArgType.BaseType.BaseType</code>, and so on, adding one for every step in the inheritance chain</li> </ul> <p>The formatter whose ForType has the smallest distance to ArgType is used to format the argument.</p>"},{"location":"formatting-argument-values/#highest-priority","title":"Highest priority","text":"<p>Sometimes more than one formatter is found the same distance from ArgType. Maybe two formatters actually specify the same <code>ForType</code> property value, or there's a formatter defined for ArgType as well as for an interface that ArgType implements.</p> <p>When multiple formatters have the same distance from the argument, FakeItEasy will select the one with the highest <code>Priority</code> property value. If multiple formatters have the same distance and the same priority, the behavior is undefined.</p> <p>All classes that extend <code>ArgumentValueFormatter&lt;T&gt;</code> have a <code>Priority</code> property that returns <code>Priority.Default</code>, unless they explicitly override it.  However, the formatters that FakeItEasy includes have a <code>Priority</code> lower than <code>Priority.Default</code>, so unless two user-supplied formatters apply to the same types, and yield the same distance when applied to a type, there's no need to override the <code>Priority</code> property.</p>"},{"location":"formatting-argument-values/#how-does-fakeiteasy-find-argument-value-formatters","title":"How does FakeItEasy find Argument Value Formatters?","text":"<p>On initialization, FakeItEasy looks for Discoverable Extension Points, including Argument Value Formatters.</p>"},{"location":"how-to-fake-internal-types/","title":"How to fake internal (Friend in VB) types","text":"<p>This guide will show you how to set up your project in order to be able to fake internal types in your tested system.</p>"},{"location":"how-to-fake-internal-types/#details","title":"Details","text":"<p>The assembly that generates the proxy instances must have access to your internal types, therefore a <code>InternalsVisibleTo</code> attribute must be added to your tested assembly. Note that it is the assembly under test, not your test-assembly that needs this attribute.</p>"},{"location":"how-to-fake-internal-types/#unsigned-assemblies","title":"Unsigned assemblies","text":"<p>If your assembly is not signed with a strong name, it's as easy as adding the following to your project file (assuming you're using .NET 5 SDK or higher):</p> <pre><code>&lt;ItemGroup&gt;\n&lt;InternalsVisibleTo Include=\"DynamicProxyGenAssembly2\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre> <p>If you're using an older SDK, you can add this to your AssemblyInfo.cs/vb file instead:</p> C#VB <pre><code>[assembly: InternalsVisibleTo(\"DynamicProxyGenAssembly2\")]\n</code></pre> <pre><code>&lt;Assembly:InternalsVisibleTo(\"DynamicProxyGenAssembly2\")&gt;\n</code></pre>"},{"location":"how-to-fake-internal-types/#signed-assemblies","title":"Signed assemblies","text":"<p>For signed assemblies, you have to specify the public key of the proxy-generating assembly in your project file:</p> <pre><code>&lt;ItemGroup&gt;\n&lt;InternalsVisibleTo Include=\"DynamicProxyGenAssembly2\" Key=\"0024000004800000940000000602000000240000525341310004000001000100c547cac37abd99c8db225ef2f6c8a3602f3b3606cc9891605d02baa56104f4cfc0734aa39b93bf7852f7d9266654753cc297e7d2edfe0bac1cdcf9f717241550e0a7b191195b7667bb4f64bcb8e2121380fd1d9d46ad2d92d2d15605093924cceaf74c4861eff62abf69b9291ed0a340e113be11e6a7d3113e92484cf7045cc7\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre> <p>Or, if using an older SDK, in your AssemblyInfo.cs/vb file:</p> C#VB <pre><code>[assembly: InternalsVisibleTo(\"DynamicProxyGenAssembly2, PublicKey=0024000004800000940000000602000000240000525341310004000001000100c547cac37abd99c8db225ef2f6c8a3602f3b3606cc9891605d02baa56104f4cfc0734aa39b93bf7852f7d9266654753cc297e7d2edfe0bac1cdcf9f717241550e0a7b191195b7667bb4f64bcb8e2121380fd1d9d46ad2d92d2d15605093924cceaf74c4861eff62abf69b9291ed0a340e113be11e6a7d3113e92484cf7045cc7\")]\n</code></pre> <pre><code>&lt;Assembly:InternalsVisibleTo(\"DynamicProxyGenAssembly2, PublicKey=0024000004800000940000000602000000240000525341310004000001000100c547cac37abd99c8db225ef2f6c8a3602f3b3606cc9891605d02baa56104f4cfc0734aa39b93bf7852f7d9266654753cc297e7d2edfe0bac1cdcf9f717241550e0a7b191195b7667bb4f64bcb8e2121380fd1d9d46ad2d92d2d15605093924cceaf74c4861eff62abf69b9291ed0a340e113be11e6a7d3113e92484cf7045cc7\")&gt;\n</code></pre>"},{"location":"implicit-creation-options/","title":"Implicit Creation Options","text":"<p>While it's possible to provide explicit creation options, this can sometimes be tedious. Sometimes you want to have every Fake of a particular type start with some basic configuration, using a <code>FakeOptionsBuilder</code>. Here's an example:</p> <pre><code>public class RobotRunsAmokEventFakeOptionsBuilder : FakeOptionsBuilder&lt;RobotRunsAmokEvent&gt;\n{\nprotected override void BuildOptions(IFakeOptions&lt;RobotRunsAmokEvent&gt; options)\n{\noptions.ConfigureFake(fake =&gt;\n{\nA.CallTo(() =&gt; fake.CalculateTimestamp())\n.Returns(new DateTime(1997, 8, 29, 2, 14, 03));\nrobotRunsAmokEvent.ID = Guid.NewGuid();\n});\n}\n}\n</code></pre> <p>This will ensure that any new <code>RobotRunsAmokEventFakeOptionsBuilder</code> will have an appropriate date applied and will have a unique ID.</p> <p>In addition to <code>ConfigureFake</code>, any explicit creation option can be used in <code>BuildOptions</code>, including implementing interfaces, providing constructor arguments, and more.</p>"},{"location":"implicit-creation-options/#how-it-works","title":"How it works","text":"<p>FakeItEasy uses classes that implement the following interface to configure Fakes:</p> <pre><code>public interface IFakeOptionsBuilder\n{\nbool CanBuildOptionsForFakeOfType(Type type);\nvoid BuildOptions(Type typeOfFake, IFakeOptions options);\nPriority Priority { get; }\n}\n</code></pre> <p>When FakeItEasy creates a Fake, it looks at all known <code>IFakeOptionsBuilder</code> implementations for which <code>CanBuildOptionsForFakeOfType</code> returns <code>true</code>. Then it passes an empty <code>options</code> object to <code>BuildOptions</code>. If multiple implementations match, the one with the highest <code>Priority</code>is used.</p> <p>If all that's needed is a Fake Options Builder that configures a single explicit type, extending <code>abstract class FakeOptionsBuilder&lt;T&gt;: IFakeOptionsBuilder</code> is preferred, as was done above. This abstract class provides default implementations of <code>Priority</code> and <code>CanBuildOptionsForFakeOfType</code> (although the <code>Priority</code> can be overridden if needed). If you want to configure a variety of Fake types, you may prefer to extend <code>IFakeOptionsBuilder</code> directly. For example, if you wanted all Fakes to be Strict, you might write something like this:</p> <pre><code>class MakeEverythingStrictOptionsBuilder : IFakeOptionsBuilder\n{\npublic bool CanBuildOptionsForFakeOfType(Type type)\n{\nreturn true;\n}\npublic void BuildOptions(Type typeOfFake, IFakeOptions options)\n{\noptions.Strict();\n}\npublic Priority Priority\n{\nget { return Priority.Default; } // equivalent to value 0\n}\n}\n</code></pre> <p>This method provides additional power, in that the Fake Options Builder can be applied to more types, but it sacrifices compile-time typesafety.  Of course, it's possible to perform more sophisticated analysis on the types, perhaps having <code>CanBuildOptionsForFakeOfType</code> accept only types whose name match a pattern. In this way, conventions-based faking could be accomplished.</p> <p>Note that once the type of Fake being created is identified, say as <code>FakedType</code>, it's possible to cast <code>options</code> to a <code>IFakeOptions&lt;FakedType&gt;</code> and operate on it, but the <code>FakedType</code> must be the exact type being faked, not just something in the inheritance tree.</p>"},{"location":"implicit-creation-options/#how-does-fakeiteasy-find-the-fake-options-builders","title":"How does FakeItEasy find the Fake Options Builders?","text":"<p>On initialization, FakeItEasy looks for Discoverable Extension Points, including Fake Options Builders.</p>"},{"location":"invoking-custom-code/","title":"Invoking Custom Code","text":"<p>Sometimes a faked method's desired behavior can't be satisfactorily defined just by specifying return values, throwing exceptions, assigning out and ref parameters or even doing nothing. Maybe you need to simulate some kind of side effect, either for the benefit of the System Under Test or to make writing a test easier (or possible). Let's see what that's like.</p> <pre><code>A.CallTo(() =&gt; fakeShop.SellSmarties())\n.Invokes(() =&gt; OrderMoreSmarties()) // simulate Smarties stock falling too low\n.Returns(20);\n</code></pre> <p>Now when the System Under Test calls <code>SellSmarties</code>, the Fake will call <code>OrderMoreSmarties</code>.</p> <p>If the method being configured has a return value, it will continue to return the default value for an unconfigured fake unless you override it with <code>Returns</code> or <code>ReturnsLazily</code>.</p> <p>There are also more advanced variants that can invoke actions based on arguments supplied to the faked method. These act similarly to how you specify return values that are calculated at call time. For example</p> <pre><code>// Pass up to 8 original call argument values into the callback method.\nA.CallTo(() =&gt; fakeShop.NumberOfSweetsSoldOn(A&lt;DateTime&gt;._))\n.Invokes((DateTime when) =&gt; System.Console.Out.WriteLine(\"showing sweet sales for \" + when))\n.Returns(17);\n// Pass an IFakeObjectCall into the callback for more advanced scenarios,\n// including configuring methods that have more than 8 parameters.\nA.CallTo(() =&gt; fakeShop.NumberOfSweetsSoldOn(A&lt;DateTime&gt;._))\n.Invokes(callObject =&gt; System.Console.Out.WriteLine(callObject.FakedObject +\n\" is closed on \" +\ncallObject.Arguments[0]));\n</code></pre>"},{"location":"invoking-custom-code/#case-study-customizing-a-readwrite-property","title":"Case study - customizing a read/write property","text":"<p>Sometimes customizing a Fake's behavior interferes with the default Fake behavior in undesired ways. For example, changing the setter behavior of a read/write property (perhaps to raise an event) can break how the <code>set</code> and <code>get</code> share values. If the setter's behavior is changed, it's necessary to explicitly retain the connection to the getter:</p> <pre><code>A.CallToSet(() =&gt; fakeShop.OpeningHours).Invokes(TimeRange newTimes) =&gt;\n{\n// have the getter return the new times when called\nA.CallTo(() =&gt; fakeShop.OpeningHours).Returns(newTimes);\n// custom action - notify listeners of the change\nfakeShop.OpeningHoursChanged += Raise.With(new HoursChangedEvent(newTimes));\n}\n</code></pre>"},{"location":"limited-call-specifications/","title":"Limited call specifications","text":"<p>This page has moved, see Changing behavior between calls.</p>"},{"location":"ordered-assertions/","title":"Ordered assertions","text":"<p>The concept of ordered assertions is somewhat complex and nothing that should be used frequently but there are times when it's really needed.</p> <p>Using FakeItEasy you can assert that calls happened in a specific order on one or more fake objects.</p>"},{"location":"ordered-assertions/#details","title":"Details","text":"<p>One area where ordered asserts are useful is when you need to test that a call to a fake has happened between two other calls, such as when dealing with transactions or units of work.</p> <pre><code>public interface IUnitOfWorkFactory\n{\nIDisposable BeginWork();\n}\npublic interface IDoSomethingPrettyUseful\n{\nvoid JustDoIt();\n}\npublic class Worker\n{\nprivate IUnitOfWorkFactory unitOfWorkFactory;\nprivate IDoSomethingPrettyUseful usefulCollaborator;\npublic Worker(IUnitOfWorkFactory unitOfWorkFactory, IDoSomethingPrettyUseful usefulCollaborator)\n{\nthis.unitOfWorkFactory = unitOfWorkFactory;\nthis.usefulCollaborator = usefulCollaborator;\n}\npublic void JustDoIt()\n{\nusing (this.unitOfWorkFactory.BeginWork())\n{\nthis.usefulCollaborator.JustDoIt();\n}\n}\n}\n</code></pre> <p>In the following example we'll assert that the call to <code>usefulCollaborator.JustDoIt()</code> happened between the calls to <code>BeginWork</code> and the <code>Dispose</code> method of the returned unit of work.</p> <pre><code>[Test]\npublic void Should_start_work_within_unit_of_work()\n{\n// Arrange\nvar unitOfWork = A.Fake&lt;IDisposable&gt;();\nvar unitOfWorkFactory = A.Fake&lt;IUnitOfWorkFactory&gt;();\nA.CallTo(() =&gt; unitOfWorkFactory.BeginWork()).Returns(unitOfWork);\nvar usefulCollaborator = A.Fake&lt;IDoSomethingPrettyUseful&gt;();\nvar worker = new Worker(unitOfWorkFactory, usefulCollaborator);\n// Act\nworker.JustDoIt();\n// Assert\nA.CallTo(() =&gt; unitOfWorkFactory.BeginWork()).MustHaveHappened()\n.Then(A.CallTo(() =&gt; usefulCollaborator.JustDoIt()).MustHaveHappened())\n.Then(A.CallTo(() =&gt; unitOfWork.Dispose()).MustHaveHappened());\n}\n</code></pre> <p>The regular <code>MustHaveHappened</code> calls are made, but the results are chained together using <code>Then</code>, which verifies not only that that call happened, but that it occurred in the right order relative to other calls that have been asserted in the same chain.</p> <p>With the current implementation of the <code>Worker</code> the test will pass. But let's change the order of the calls in <code>JustDoIt</code>:</p> <pre><code>public void JustDoIt()\n{ using (this.unitOfWorkFactory.BeginWork())\n{ }\nthis.usefulCollaborator.JustDoIt();\n}\n</code></pre> <p>The test will now fail with the following exception message:</p> <pre>\n Assertion failed for the following calls:\n    'OrderedAssertsDemo.IUnitOfWorkFactory.BeginWork()' once or more\n    'OrderedAssertsDemo.IDoSomethingPrettyUseful.JustDoIt()' once or more\n    'System.IDisposable.Dispose()' once or more\n  The calls where found but not in the correct order among the calls:\n    1.  'OrderedAssertsDemo.IUnitOfWorkFactory.BeginWork()'\n    2.  'System.IDisposable.Dispose()'\n    3.  'OrderedAssertsDemo.IDoSomethingPrettyUseful.JustDoIt()'\n</pre>"},{"location":"platform-support/","title":"Platform support","text":""},{"location":"platform-support/#supported-platforms-for-released-versions","title":"Supported platforms for released versions","text":"<p>See the \"Dependencies\" section of the FakeItEasy NuGet Gallery page to see each released package's supported platforms and package dependencies.</p>"},{"location":"platform-support/#platform-support-policy","title":"Platform support policy","text":"<p>Beginning with FakeItEasy 8.0.0, we intend to publish new packages that target</p> <ul> <li>.NET versions designated as Long Term Support (LTS) and currently supported by Microsoft</li> <li>.NET Standard 2.0 and 2.11</li> <li>.NET Framework 4.6.22</li> </ul> <p>See the .NET Support Policy to learn which target frameworks are categorized as \"Long Term Support\", and when support begins and ends.</p> <p>We will add builds for new LTS .NET versions as they are released, and remove them from new FakeItEasy builds once support is ended.</p> <p>It's not clear that there's a global consensus on whether the removal of a supported target framework constitutes a breaking change and therefore requires a new major version. We choose to limit surprises to FakeItEasy's clients and issue a new major release when dropping a supported target framework.</p> <ol> <li> <p>There are no explicit plans to remove support for .NET Standard target frameworks, but we may do so if Microsoft explicitly ends support for them, or if supporting them within FakeItEasy becomes too onerous.\u00a0\u21a9</p> </li> <li> <p>There are no explicit plans to remove support for .NET Framework, but we may increase the supported version or remove support if Microsoft ends support for .NET Framework, or if supporting it within FakeItEasy becomes too onerous.\u00a0\u21a9</p> </li> </ol>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Getting started with FakeItEasy is very simple:</p> <ul> <li>Open the Package Manager Console: Tools \u2192 Library Package Manager \u2192 Package Manager Console</li> <li>Execute <code>Install-Package FakeItEasy</code></li> <li>Start faking dependencies in your tests. Here's a sample test class with fakes:</li> </ul> <pre><code>namespace FakeItEasyQuickstart\n{\nusing FakeItEasy;\nusing NUnit; // any test framework will do\npublic class SweetToothTests\n{\n[Test]\npublic void BuyTastiestCandy_should_buy_top_selling_candy_from_shop()\n{\n// make some fakes for the test\nvar lollipop = A.Fake&lt;ICandy&gt;();\nvar shop = A.Fake&lt;ICandyShop&gt;();\n// set up a call to return a value\nA.CallTo(() =&gt; shop.GetTopSellingCandy()).Returns(lollipop);\n// use the fake as an actual instance of the faked type\nvar developer = new SweetTooth();\ndeveloper.BuyTastiestCandy(shop);\n// asserting uses the exact same syntax as when configuring calls\u2014\n// no need to learn another syntax\nA.CallTo(() =&gt; shop.BuyCandy(lollipop)).MustHaveHappened();\n}\n}\n}\n</code></pre> <ul> <li>Most FakeItEasy functionality is reached from a common entry point: the <code>A</code> class.</li> <li>In this example the <code>lollipop</code> instance is used as a stub and the <code>shop</code> instance is used as a mock but there's no need to know the difference, just fake it! Easy!</li> <li>Fluent, easy-to-use syntax guides you as you configure fakes.</li> </ul>"},{"location":"raising-events/","title":"Raising events","text":"<p>FakeItEasy can be used to simulate the raising of an event from a Fake object, assuming the event is virtual or abstract, or defined on an interface.</p>"},{"location":"raising-events/#eventhandler-based-events","title":"<code>EventHandler</code>-based events","text":"<p>Suppose a standard <code>EventHandler</code>-based event such as this one:</p> <pre><code>public interface IRobot\n{\nevent EventHandler FellInLove;\n}\n</code></pre> <p>You can raise that event, specifying sender and event arguments. You could also omit the sender and the Fake will be passed as sender to the event handler, and there's also a convenience method for raising with empty event arguments:</p> <pre><code>var robot = A.Fake&lt;IRobot&gt;();\n// Somehow use the fake from the code being tested\n// Raise the event!\nrobot.FellInLove += Raise.With(someEventArgs); // the \"sender\" will be robot\n// Use the overload for empty event args. Sender will be robot, args will be EventArgs.Empty\nrobot.FellInLove += Raise.WithEmpty();\n// Specify sender and event args explicitly:\nrobot.FellInLove += Raise.With(sender: robot, e: someEventArgs);\n</code></pre>"},{"location":"raising-events/#vbnet-syntax","title":"VB.NET syntax","text":"<pre><code>' Raise the event!\nAddHandler robot.FellInLove, Raise.With(someEventArgs) ' the \"sender\" will be robot\n' Use the overload for empty event args. Sender will be robot, args will be EventArgs.Empty\nAddHandler robot.FellInLove, Raise.WithEmpty()\n' Specify sender and event args explicitly:\nAddHandler robot.FellInLove, Raise.With(sender, someEventArgs)\n</code></pre>"},{"location":"raising-events/#raising-eventhandlerteventargs","title":"Raising <code>EventHandler&lt;TEventArgs&gt;</code>","text":"<p>Events of type <code>EventHandler&lt;TEventArgs&gt;</code> can be raised in exactly the same way.</p>"},{"location":"raising-events/#free-form-events-using-arbitrary-delegates","title":"\"Free-form\" events using arbitrary delegates","text":"<p>It is also possible to raise events defined using a custom delegate (a.k.a \"free-form delegate\"), like these:</p> <pre><code>public delegate void FreeformEventHandler(int count);\npublic delegate void CustomEventHandler(object sender, CustomEventArgs e);\n\u2026\nevent FreeformEventHandler FreeformEvent;\nevent CustomEventHandler CustomEvent;\n</code></pre>"},{"location":"raising-events/#from-c","title":"From C#","text":"<p>To raise a free-form event from C#, use <code>Raise.FreeForm.With</code>, which automatically infers the correct delegate type:</p> <pre><code>fake.FreeformEvent += Raise.FreeForm.With(7);\nfake.CustomEvent += Raise.FreeForm.With(fake, sampleCustomEventArgs);\n</code></pre> <p>Due to language limitations, <code>Raise.Freeform.With</code> does not work in VB.NET, and it uses late binding, so you need a reference to the <code>Microsoft.CSharp</code> assembly in order to use it.</p>"},{"location":"raising-events/#from-vbnet","title":"From VB.NET","text":"<p>To raise a free-form event from VB.NET, you must use <code>Raise.FreeForm(Of TEventHandler).With</code>:</p> <pre><code>AddHandler fake.FreeformEvent, Raise.FreeForm(Of FreeformEventHandler).With(7)\nAddHandler fake.CustomEvent, Raise.FreeForm(Of CustomEventHandler).With(fake, sampleCustomEventArgs)\n</code></pre> <p>Specifying the type of the event handler gets around the language restrictions in VB.NET. This method may also be used from C# if you don't want to rely on late binding.</p>"},{"location":"raising-events/#limitations","title":"Limitations","text":"<p>The approach described above for raising events doesn't work in some situations:</p> <ul> <li>Wrapping fakes</li> <li>Fakes configured to call base methods</li> </ul> <p>This is because the calls (including event subscription and unsubscription) are forwarded to another implementation (wrapped object or base class) that FakeItEasy has no control over, so the fake doesn't know about the handlers and cannot call them.</p> <p>Similarly, strict fakes don't handle any call unless explicitly configured, including event subscription or unsubscription, so FakeItEasy also can't raise events on strict fakes.</p> <p>To work around this limitation, you have three options:</p> <ul> <li> <p>For a strict fake, you can enable the default event behavior on the fake at creation time.</p> </li> <li> <p>You can explicitly enable the default event behavior on the fake, for a specific event or for all events of the fake:</p> </li> </ul> <pre><code>Manage.Event(\"FellInLove\").Of(robot);\nManage.AllEvents.Of(robot);\n</code></pre> <ul> <li>If you need more control, you can explicitly configure the calls to the event accessors to handle event subscription yourself, as in the example below:</li> </ul> <pre><code>// Declare a delegate to store the event handlers\nEventHandler handlers = null;\n// Configure event subscription on the fake\nA.CallTo(robot, EventAction.Add(\"FellInLove\")).Invokes((EventHandler h) =&gt; handlers += h);\nA.CallTo(robot, EventAction.Remove(\"FellInLove\")).Invokes((EventHandler h) =&gt; handlers -= h);\n// Raise the event\nhandlers?.Invoke(robot, EventArgs.Empty);\n</code></pre>"},{"location":"read-write-property-behavior/","title":"Read write property behavior","text":"<p>The contents of this page have moved. See * Default fake behavior for information about unconfigured properties and * Specifying a Call to Configure for how to configure a property.</p>"},{"location":"scanning-for-extension-points/","title":"Scanning for Extension Points","text":"<p>On initialization, essentially as soon as a FakeItEasy type is accessed, FakeItEasy uses reflection to look for internal and user-supplied extension points. In most cases, there is no need for users to define any extensions, but they may be used to enhance the power and usability of FakeItEasy.</p> <p>There are currently four kinds of extension points defined:</p> <ul> <li>Custom Dummy Creation rules,</li> <li>Implicit Creation Options,</li> <li>Argument Value Formatters, and</li> <li>Argument Equality Comparers</li> </ul> <p>Please see their individual documentation to learn how each of these is used.</p>"},{"location":"scanning-for-extension-points/#the-scanning-process","title":"The scanning process","text":"<p>On startup, FakeItEasy searches the following assemblies for classes that implement the various extensions points:</p> <ul> <li>its own assembly,</li> <li>assemblies already loaded in the current AppDomain, if they reference   FakeItEasy,</li> <li>assemblies referenced by assemblies from the previous bullet point, if they   reference FakeItEasy,</li> <li>additional assemblies identified by the Bootstrapper's   <code>GetAssemblyFileNamesToScanForExtensions</code> method, if they reference   FakeItEasy.</li> </ul> <p>Any such classes found are added to a catalogue and used at need.</p>"},{"location":"source-stepping/","title":"Source Stepping","text":"<p>In most cases, you'll never need to step through the FakeItEasy source code, but occasionally, it may help to see what FakeItEasy is doing under the hood. FakeItEasy uses SourceLink to make it a breeze to step into the FakeItEasy source code.</p> <p>To enable SourceLink, follow the instructions below depending on your IDE or editor. Then, during your debug session, when you step into a FakeItEasy method call, the debugger will download the source code from GitHub so you can step through it.</p>"},{"location":"source-stepping/#visual-studio","title":"Visual Studio","text":"<p>Requires at least Visual Studio 2017 v15.3. Tested with VS 2019 16.4.2.</p> <ol> <li>Tools \u2192 Options \u2192 Debugging \u2192 General \u2192 Enable Just My Code: Uncheck</li> <li>Tools \u2192 Options \u2192 Debugging \u2192 General \u2192 Enable Source Link support: Check</li> </ol>"},{"location":"source-stepping/#visual-studio-code","title":"Visual Studio Code","text":"<p>Tested with VS Code 1.40.2.</p> <p>In the launch configuration in the <code>launch.json</code> file, set <code>justMyCode</code> to false.</p>"},{"location":"source-stepping/#jetbrains-rider","title":"JetBrains Rider","text":"<p>Tested with Rider 2019.3.</p> <p>Settings \u2192 Build, Execution, Deployment \u2192 Debugger \u2192 Enable external source debug: Check</p> <p>Note: The instructions above have been tested, but the maintainers don't necessarily use all the tools mentioned, so they may become outdated. Please let us know if they no longer work!</p>"},{"location":"specifying-a-call-to-configure/","title":"Specifying a Call to Configure","text":"<p>One of the first steps in configuring a fake object's behavior is to specify which call to configure. Like most FakeItEasy actions, this is done using a method on the <code>A</code> class: <code>A.CallTo</code>.</p>"},{"location":"specifying-a-call-to-configure/#specifying-a-method-call-or-property-get-using-an-expression","title":"Specifying a method call or property <code>get</code> using an Expression","text":"<pre><code>A.CallTo(() =&gt; fakeShop.GetTopSellingCandy()).Returns(lollipop);\nA.CallTo(() =&gt; fakeShop.Address).Returns(\"123 Fake Street\");\n</code></pre> <p>The expressions in the above example are not evaluated by FakeItEasy: no call to <code>GetTopSellingCandy</code> or <code>Address</code> is made. The expressions are just used to identify which call to configure, after which <code>A.CallTo</code> returns an object that can be used to specify how the fake should behave when the call is made.</p> Use an action to complete call configuration <p>Specifying the call via <code>A.CallTo</code> and related methods does not have any effect on the fake object. You must include an action for the call to perform to alter the behavior of the fake object.</p> <p>There are many types of actions that can be specified, including returning various values, throwing exceptions, and more. Even doing nothing, which may be required for a void method.</p>"},{"location":"specifying-a-call-to-configure/#specifying-a-call-to-a-property-setter","title":"Specifying a call to a property setter","text":"<p>Assignment operators can't be used in lambda expressions, so the <code>A.CallTo</code> overloads described above cannot be used to configure calls to property setters. Use <code>A.CallToSet</code> to configure the <code>set</code> behavior of read/write properties:</p> <pre><code>A.CallToSet(() =&gt; fakeShop.Address).To(\"123 Fake Street\").CallsBaseMethod();\nA.CallToSet(() =&gt; fakeShop.Address).To(() =&gt; A&lt;string&gt;.That.StartsWith(\"123\")).DoesNothing();\nA.CallToSet(() =&gt; fakeShop.Address).DoesNothing(); // ignores the value that's set\n</code></pre> <p>Argument constraints can be used to constrain the value that's set into the property, or the indexes that must be supplied when invoking an indexer.</p> <p>Note that any customization of a read/write property's behavior will break the default behavior of having the getter return the last set value. To avoid this, a custom action may be used to preserve the behavior.</p>"},{"location":"specifying-a-call-to-configure/#specifying-the-invocation-of-a-delegate","title":"Specifying the invocation of a delegate","text":"<p>To specify the invocation of a delegate, just use <code>A.CallTo</code>, invoking the fake delegate as you normally would:</p> <pre><code>var deepThought = A.Fake&lt;Func&lt;string, int&gt;&gt;();\nA.CallTo(() =&gt; deepThought.Invoke(\"What is the answer to life, the universe, and everything?\")).Returns(42);\n// Note that the .Invoke part is optional:\nA.CallTo(() =&gt; deepThought(\"What is the answer to life, the universe, and everything?\")).Returns(42);\n</code></pre>"},{"location":"specifying-a-call-to-configure/#specifying-a-call-to-an-explicitly-implemented-interface-member","title":"Specifying a call to an explicitly implemented interface member","text":"<p>An explicitly implemented member is not directly visible on the concrete class. Instead, it has to be called (or overridden) via the interface. In addition, since fakes don't automatically intercept explicitly implemented interfaces, you need to explicitly specify that the fake implements the interface:</p> <pre><code>var fakeShop = A.Fake&lt;CandyShop&gt;(options =&gt; options.Implements&lt;ICandyShop&gt;());\nA.CallTo(() =&gt; ((ICandyShop)fakeShop).GetTopSellingCandy()).Returns(lollipop);\n</code></pre>"},{"location":"specifying-a-call-to-configure/#specifying-a-call-to-any-method-or-property","title":"Specifying a call to any method or property","text":"<p>Instead of supplying an expression to identify a specific method, pass the fake to <code>A.CallTo</code> to refer to any method on the fake:</p> <pre><code>A.CallTo(fakeShop).Throws(new Exception());\n// Or limit the calls to void methods\nA.CallTo(fakeShop).WithVoidReturnType().Throws(\"sugar overflow\");\n// Or limit the calls by return type\nA.CallTo(fakeShop).WithReturnType&lt;string&gt;().Returns(\"sugar tastes good\");\n// Or limit the calls to methods that return a value. Note that it will throw at runtime\n// if the configured return value doesn't match the called method's return type.\nA.CallTo(fakeShop).WithNonVoidReturnType().Returns(\"sugar tastes good\");\n// Or create a sophisticated test with a predicate that acts on an IFakeObjectCall.\n// One use case is when the call's arguments include an object of an anonymous type,\n// since it's impossible to create argument constraints for anonymous types.\nA.CallTo(fakeShop).Where(call =&gt; call.Method.Name == \"AnonymousArgEater\")\n.WithReturnType&lt;string&gt;()\n.Returns(\"no-name candy\");\n</code></pre> <p><code>A.CallTo(object)</code> can also be used to specify write-only properties and <code>protected</code> members:</p> <pre><code>A.CallTo(fakeShop).Where(call =&gt; call.Method.Name == \"ProtectedCalculateSalesForToday\")\n.WithReturnType&lt;double&gt;()\n.Returns(4741.71);\n// Use the conventional .NET prefix \"get_\" to refer to a property's getter:\nA.CallTo(fakeShop).Where(call =&gt; call.Method.Name == \"get_Address\")\n.WithReturnType&lt;string&gt;()\n.Returns(\"123 Fake Street\");\n// Use the conventional .NET prefix \"set_\" to refer to a property's setter:\nA.CallTo(fakeShop).Where(call =&gt; call.Method.Name == \"set_Address\")\n.Throws(new Exception(\"we can't move\"));\n</code></pre>"},{"location":"specifying-a-call-to-configure/#specifying-a-call-to-an-event-accessor","title":"Specifying a call to an event accessor","text":"<p>Although calls to event accessors can be specified using the approach described in the previous section, FakeItEasy also provides helper methods to make this easier:</p> <pre><code>// Specifies a call to the add accessor of the MyEvent event of the fake\nA.CallTo(fake, EventAction.Add(\"MyEvent\")).Invokes((EventHandler h) =&gt; ...);\n// Specifies a call to the remove accessor of the MyEvent event of the fake\nA.CallTo(fake, EventAction.Remove(\"MyEvent\")).Invokes((EventHandler h) =&gt; ...);\n// Specifies a call to the add accessor of any event of the fake\nA.CallTo(fake, EventAction.Add()).Invokes(...);\n// Specifies a call to the remove accessor of any event of the fake\nA.CallTo(fake, EventAction.Remove()).Invokes(...);\n</code></pre>"},{"location":"specifying-a-call-to-configure/#vbnet","title":"VB.Net","text":"<p>Special syntax is provided to specify <code>Func</code>s and <code>Sub</code>s in VB, using their respective keywords:</p> <pre><code>A.CallTo(Sub() fakeShop.SellSomething())\n                       .DoesNothing()\n\nA.CallTo(Func() fakeShop.GetTopSellingCandy())\n                        .Returns(lollipop)\n</code></pre>"},{"location":"specifying-return-values/","title":"Specifying Return Values","text":"<p>One of the most common tasks on a newly-created Fake is to specify the return value for some method or property that might be called on it. This is often done by using the <code>Returns</code> method on the result of an <code>A.CallTo</code>:</p> <pre><code>A.CallTo(() =&gt; fakeShop.GetTopSellingCandy()).Returns(lollipop);\n</code></pre> <p>Now, whenever the parameterless method <code>GetTopSellingCandy</code> is called on the <code>fakeShop</code> Fake, it will return the <code>lollipop</code> object.</p> <p>A <code>get</code> property on a Fake can be configured similarly: <pre><code>A.CallTo(() =&gt; fakeShop.Address).Returns(\"123 Fake Street\");\n</code></pre></p>"},{"location":"specifying-return-values/#return-values-calculated-at-call-time","title":"Return Values Calculated at Call Time","text":"<p>Sometimes a desired return value won't be known at the time the call is configured. <code>ReturnsNextFromSequence</code> and <code>ReturnsLazily</code> can help with that. <code>ReturnsNextFromSequence</code> is the simpler of the two:</p> <pre><code>A.CallTo(() =&gt; fakeShop.SellSweetFromShelf())\n.ReturnsNextFromSequence(lollipop, smarties, wineGums);\n</code></pre> <p>will first return <code>lollipop</code>, then <code>smarties</code>, then <code>wineGums</code>. The next call will not take an item from the sequence, but will rely on other configured (or default) behavior.</p> <p>On to the very powerful <code>ReturnsLazily</code>:</p> <pre><code>// Returns the number of times the method has been called\nint sweetsSold = 0;\nA.CallTo(() =&gt; fakeShop.NumberOfSweetsSoldToday()).ReturnsLazily(() =&gt; ++sweetsSold);\n</code></pre> <p>If a return value depends on input to the method, those values can be incorporated in the calculation. Convenient overloads exist for methods of up to 8 parameters.</p> <pre><code>A.CallTo(() =&gt; fakeShop.NumberOfSweetsSoldOn(A&lt;DateTime&gt;.Ignored)) .ReturnsLazily((DateTime theDate) =&gt; theDate.DayOfWeek == DayOfWeek.Sunday ? 0 : 200);\n</code></pre> <p>The convenience methods may be used with methods that take <code>out</code> and <code>ref</code> parameters. This means that the previous example would work even if <code>NumberOfSweetsSoldOn</code> took an <code>out DateTime</code> or a <code>ref DateTime</code>.</p> <p>Note that the type of the <code>Func</code> sent to <code>ReturnsLazily</code> isn't checked at compile time, but any type mismatch will trigger a helpful error message.</p> <p>If more advanced decision-making is required, or the method has more than 8 parameters, the convenience methods won't work. Use the variant that takes an <code>IFakeObjectCall</code> instead:</p> <pre><code>A.CallTo(() =&gt; fakeShop.SomeCall(\u2026))\n                       .ReturnsLazily(objectCall =&gt; calculateReturnFrom(objectCall));\n</code></pre> <p>The <code>IFakeObjectCall</code> object provides access to</p> <ul> <li>information about the <code>Method</code> being called, as a <code>MethodInfo</code>,</li> <li>the <code>Arguments</code>, accessed by position or name, and</li> <li>the original <code>FakedObject</code></li> </ul>"},{"location":"strict-fakes/","title":"Strict fakes","text":"<p>By default, FakeItEasy's fakes support what is sometimes called \"loose mocking\". This means that calls to any of the fake's members are allowed, even if they haven't been configured.</p> <p>However, FakeItEasy also supports strict fakes, in which all calls to unconfigured members are rejected, throwing an <code>ExpectationException</code>. Strict fakes are created by supplying a creation option:</p> <pre><code>var foo = A.Fake&lt;IFoo&gt;(x =&gt; x.Strict());\n</code></pre> <p>After you have configured your fake in this fashion you can configure any \"allowed\" calls as usual, for example:</p> <pre><code>A.CallTo(() =&gt; foo.Bar()).Returns(\"bar\");\n</code></pre> <p>Strict fakes are useful when it is important to ensure that no calls are made to your fake other than the ones you are expecting.</p>"},{"location":"strict-fakes/#object-members","title":"Object members","text":"<p>It can sometimes be inconvenient that all methods throw an exception if not configured. You might want to allow calls to methods inherited from <code>System.Object</code> (<code>Equals</code>, <code>GetHashCode</code> and <code>ToString</code>), because they're used all the time, often implicitly, and in most cases there's no real value in configuring them manually.</p> <p>To achieve this, pass a <code>StrictFakeOptions</code> value to the <code>Strict</code> method when you create the fake:</p> <pre><code>// Allow calls to all object methods\nvar foo = A.Fake&lt;IFoo&gt;(x =&gt; x.Strict(StrictFakeOptions.AllowObjectMethods));\n// Allow calls to ToString\nvar foo = A.Fake&lt;IFoo&gt;(x =&gt; x.Strict(StrictFakeOptions.AllowToString));\n// Allow calls to Equals and GetHashCode\nvar foo = A.Fake&lt;IFoo&gt;(x =&gt; x.Strict(StrictFakeOptions.AllowEquals | StrictFakeOptions.AllowGetHashCode));\n</code></pre>"},{"location":"strict-fakes/#events","title":"Events","text":"<p>By default, calls to event accessors of a strict fake will fail if the calls are not configured. Although you can manually handle event subscription or unsubscription, there's often not much value in doing this manually. You can allow a strict fake to manage events automatically by passing the <code>AllowEvents</code> flag to the <code>Strict</code> method:</p> <pre><code>var foo = A.Fake&lt;IFoo&gt;(x =&gt; x.Strict(StrictFakeOptions.AllowEvents));\n</code></pre>"},{"location":"throwing-exceptions/","title":"Throwing Exceptions","text":"<p>When it's deployed, you may not want code to throw exceptions, but often it's necessary to test what happens when libraries your code interacts with throw them. You can configure a Fake to throw an exception like this:</p> <pre><code>A.CallTo(() =&gt; fakeShop.NumberOfSweetsSoldOn(DateTime.MaxValue))\n.Throws(new InvalidDateException(\"the date is in the future\"));\n</code></pre> <p>If the exception type has a parameterless constructor, you can use it like</p> <pre><code>A.CallTo(() =&gt; fakeShop.NumberOfSweetsSoldOn(DateTime.MaxValue))\n.Throws&lt;InvalidDateException&gt;();\n</code></pre> <p>There are also more advanced methods that can throw exceptions based on values calculated at runtime. These act similarly to how you specify return values that are calculated at call time. For example</p> <pre><code>// Generate the exception at call time.\nA.CallTo(() =&gt; fakeShop.NumberOfSweetsSoldOn(A&lt;DateTime&gt;._))\n.Throws(() =&gt; new InvalidDateException(DateTime.UtcNow + \" is in the future\"));\n// Pass up to 8 original call argument values into the method that creates the exception.\nA.CallTo(() =&gt; fakeShop.NumberOfSweetsSoldOn(A&lt;DateTime&gt;._))\n.Throws((DateTime when)=&gt;new InvalidDateException(when + \" is in the future\"));\n// Pass an IFakeObjectCall into the creation method for more advanced scenarios,\n// including throwing an exception from a method that has more than 8 parameters.\nA.CallTo(() =&gt; fakeShop.NumberOfSweetsSoldOn(A&lt;DateTime&gt;._))\n.Throws(callObject =&gt; new InvalidDateException(callObject.FakedObject +\n\" is closed on \" +\ncallObject.Arguments[0]));\n</code></pre>"},{"location":"throwing-exceptions/#throwing-exceptions-from-an-async-method","title":"Throwing exceptions from an async method","text":"<p>When a method returns a <code>Task</code> or <code>Task&lt;T&gt;</code>, there are two ways it can indicate failure via an exception:</p> <ul> <li>throw the exception synchronously, i.e. not actually return a <code>Task</code></li> <li>\"throw asynchronously\", i.e. return a failed task with the exception.</li> </ul> <p>The former is supported by the <code>Throws</code> method described above, in the same way as if the method was synchronous. The latter can be configured by using the <code>ThrowsAsync</code> method:</p> <pre><code>A.CallTo(() =&gt; fakeShop.OrderSweetsAsync(\"cheeseburger\"))\n.ThrowsAsync(new ArgumentException(\"'cheeseburger' isn't a valid sweet category\"));\n</code></pre> <p>This will cause the configured method to return a failed <code>Task</code> whose <code>Exception</code> property is set to the exception specified in <code>ThrowsAsync</code>.</p> <p>As with <code>Throws</code> above, <code>ThrowsAsync</code> has several overloads, including those that take <code>Func</code>s of up to 8 parameters, and one that takes a <code>Func</code> that operates on an <code>IFakeObjectCall</code>. The latter is suitable for examining, in detail, the call that triggers the exception, or for configuring a method that has more than 8 parameters.</p> <p>These overloads of <code>ThrowsAsync</code> also exist for <code>ValueTask</code> and <code>ValueTask&lt;T&gt;</code>. If your test project targets a framework compatible with .NET Standard 2.1 or higher, they're built into FakeItEasy itself; otherwise, they're in a separate package: <code>FakeItEasy.Extensions.ValueTask</code>.</p>"},{"location":"what-can-be-faked/","title":"What can be faked","text":""},{"location":"what-can-be-faked/#what-types-can-be-faked","title":"What types can be faked?","text":"<p>FakeItEasy uses Castle DynamicProxy to create fakes. Thus, it can fake just about anything that could normally be overridden, extended, or implemented.  This means that the following entities can be faked:</p> <ul> <li>interfaces</li> <li>classes that<ul> <li>are not sealed,</li> <li>are not static, and</li> <li>have at least one public or protected constructor whose arguments FakeItEasy can construct or obtain</li> </ul> </li> <li>delegates</li> </ul> <p>Note that special steps will need to be taken to fake internal interfaces and classes.</p>"},{"location":"what-can-be-faked/#types-whose-methods-have-in-parameters","title":"Types whose methods have <code>in</code> parameters","text":"<p>Due to deficiencies in earlier .NET framework releases, generic types that contain methods having a parameter modified by the <code>in</code> keyword cannot be faked by FakeItEasy running on target frameworks earlier than .NET 6.</p>"},{"location":"what-can-be-faked/#where-do-the-constructor-arguments-come-from","title":"Where do the constructor arguments come from?","text":"<ul> <li>they can be supplied via <code>WithArgumentsForConstructor</code> as shown in   creating fakes, or</li> <li>FakeItEasy will use dummies as arguments</li> </ul>"},{"location":"what-can-be-faked/#what-members-can-be-overridden","title":"What members can be overridden?","text":"<p>Once a fake has been constructed, its methods and properties can be overridden if they are:</p> <ul> <li>virtual,</li> <li>abstract, or</li> <li>an interface method when an interface is being faked</li> </ul> <p>Note that this means that static members, including extension methods, cannot be overridden.</p>"},{"location":"what-can-be-faked/#methods-that-return-values-by-reference","title":"Methods that return values by reference","text":"<p>Methods that return values by reference (officially called \"reference return values\") cannot be invoked on a Fake. Any attempt to do so will result in a <code>NullReferenceException</code> being thrown.</p>"},{"location":"why-was-fakeiteasy-created/","title":"Why was FakeItEasy created?","text":""},{"location":"why-was-fakeiteasy-created/#introduction","title":"Introduction","text":"<p>There was a good question on Stack Overflow that asks what distinguishes FakeItEasy from other libraries. Creator of FakeItEasy, Patrik H\u00e4gne, answered the question there but we reproduce the answer here. Note that the text has been preserved, and particular constructs referenced (such as <code>DummyDefinitions</code>) have changed or been renamed in newer versions of FakeItEasy.</p> <p>The question on Stack Overflow: \"Are fakes better than Mocks?\"</p>"},{"location":"why-was-fakeiteasy-created/#patrik-hgnes-answer","title":"Patrik H\u00e4gne's answer","text":"<p>To be clear, I created FakeItEasy so I'll definitely not say whether one framework is better than the other, what I can do is point out some differences and motivate why I created FakeItEasy. Functionally there are no major differences between Moq and FakeItEasy.</p> <p>FakeItEasy has no \"Verifiable\" or \"Expectations\" it has assertions however, these are always explicitly stated at the very end of a test, I believe this makes tests easier to read and understand. It also helps beginners to avoid multiple asserts (where they would set expectations on many calls or mock objects).</p> <p>I used Rhino Mocks before and I quite liked it, especially after the AAA-syntax was introduced I did like the fluent API of Moq better though. What I didn't like with Moq was the \"mock object\" where you have to use mock.Object everywhere, I like the Rhino-approach with \"natural\" mocks better. Every instance looks and feels like a normal instance of the faked type. I wanted the best of both worlds and also I wanted to see what I could do with the syntax when I had absolutely free hands. Personally I (obviously) think I created something that is a good mix with the best from both world, but that's quite easy when you're standing on the shoulders of giants.</p> <p>As has been mentioned here one of the main differences is in the terminology, FakeItEasy was first created to introduce TDD and mocking to beginners and having to worry about the differences between mocks and stubs up front is not very useful.</p> <p>I've put a lot of focus into the exception messages, it should be very easy to tell what went wrong in a test just looking at an exception message.</p> <p>FakeItEasy has some extensibility features that the other frameworks don't have but these aren't very well documented yet.</p> <p>FakeItEasy is (hopefully) a little stronger in mocking classes that has constructor arguments since it has a mechanism for resolving dummy-values to use. You can even specify your own dummy value definitions by implementing a DummyDefinition(Of T) class within your test project, this will automatically be picked up by FakeItEasy.</p> <p>The syntax is an obvious difference, which one is better is largely a matter of taste.</p> <p>I'm sure there are lots of other differences that I forget about now (and to be fair I've never used Moq in production myself so my knowledge of it is limited), I do think these are the most important differences though.</p>"},{"location":"Recipes/faking-http-client/","title":"Faking HttpClient","text":"<p>Let's assume that you want to create a fake <code>HttpClient</code> so you can dictate the behavior of the GetAsync(String) method. This seems like it would be a straightforward task, but it's complicated by the design of <code>HttpClient</code>, which is not faking-friendly.</p>"},{"location":"Recipes/faking-http-client/#a-working-fake","title":"A working Fake","text":"<p>First off, let's look at the declaration of <code>GetAsync</code>:</p> <pre><code>public Task&lt;HttpResponseMessage&gt;GetAsync(string? requestUri)\n</code></pre> <p>This method is neither virtual nor abstract, and so can't be overridden by FakeItEasy.</p> <p>As a workaround, we can look at the definition of GetAsync and see that the method eventually ends up calling HttpMessageHandler.SendAsync(HttpRequestMessage, CancellationToken) on an <code>HttpMessageHandler</code> that can be supplied via the <code>HttpClient</code> constructor.</p> <p><code>HttpMessageHandler.SendAsync</code> is protected, which makes it less convenient to override than a public method. We need to specify the call by name, and to give FakeItEasy a hint about the return type, as described in Specifying a call to any method or property.</p> <p>With this knowledge, we can write a passing test:</p> This is a simplified example <p>In the interest of brevity, we create a Fake, exercise it directly, and check its behavior. A more realistic example would create the Fake as a collaborator of some production class (the \"system under test\") and the Fake would not be called directly from the test code.</p> <pre><code>[Fact]\npublic async Task FakeAnyMethodWay()\n{\nusing var response = new HttpResponseMessage\n{\nContent = new StringContent(\"FakeItEasy is fun\")\n};\nvar handler = A.Fake&lt;HttpMessageHandler&gt;();\nA.CallTo(handler)\n.WithReturnType&lt;Task&lt;HttpResponseMessage&gt;&gt;()\n.Where(call =&gt; call.Method.Name == \"SendAsync\")\n.Returns(response);\nusing var client = new HttpClient(handler);\nvar result = await client.GetAsync(\"https://fakeiteasy.github.io/docs/\");\nvar content = await result.Content.ReadAsStringAsync();\ncontent.Should().Be(\"FakeItEasy is fun\");\n}\n</code></pre>"},{"location":"Recipes/faking-http-client/#easier-and-safer-call-configuration","title":"Easier and safer call configuration","text":"<p>The above code works, but specifying the method name and return type is a little awkward. A <code>FakeableHttpMessageHandler</code> class can be used to clean things up and to also supply a little compile-time safety by ensuring we're configuring the expected method.</p> <pre><code>public abstract class FakeableHttpMessageHandler : HttpMessageHandler\n{\npublic abstract Task&lt;HttpResponseMessage&gt; FakeSendAsync(\nHttpRequestMessage request, CancellationToken cancellationToken);\n// sealed so FakeItEasy won't intercept calls to this method\nprotected sealed override Task&lt;HttpResponseMessage&gt; SendAsync(\nHttpRequestMessage request, CancellationToken cancellationToken)\n=&gt; this.FakeSendAsync(request, cancellationToken);\n}\n[Fact]\npublic async Task FakeByMakingMessageHandlerFakeable()\n{\nusing var response = new HttpResponseMessage\n{\nContent = new StringContent(\"FakeItEasy is fun\")\n};\nvar handler = A.Fake&lt;FakeableHttpMessageHandler&gt;();\nA.CallTo(() =&gt; handler.FakeSendAsync(\nA&lt;HttpRequestMessage&gt;.Ignored, A&lt;CancellationToken&gt;.Ignored))\n.Returns(response);\nusing var client = new HttpClient(handler);\nvar result = await client.GetAsync(\"https://fakeiteasy.github.io/docs/\");\nvar content = await result.Content.ReadAsStringAsync();\ncontent.Should().Be(\"FakeItEasy is fun\");\n}\n</code></pre>"},{"location":"Recipes/faking-http-client/#faking-postasync","title":"Faking PostAsync","text":"<p>The techniques above can be used to intercept calls to  methods other than <code>GetAsync</code> as well.</p> <p>Consider this test, which ensures that the correct content is passed to <code>HttpClient.PostAsync</code>.</p> Does not work for .NET Framework <p>When run under .NET Framework, the request content is disposed as soon as the request is made, as explained in HttpClient source code comments.</p> <pre><code>[Fact]\npublic async Task FakePostAsync()\n{\nvar handler = A.Fake&lt;FakeableHttpMessageHandler&gt;();\nusing var client = new HttpClient(handler);\nusing var postContent = new StringContent(\"my post\");\nawait client.PostAsync(\n\"https://fakeiteasy.github.io/docs/\", postContent);\nA.CallTo(() =&gt; handler.FakeSendAsync(\nA&lt;HttpRequestMessage&gt;.That.Matches(\nm =&gt; m.Content!.ReadAsStringAsync().Result == \"my post\"),\nA&lt;CancellationToken&gt;.Ignored))\n.MustHaveHappened();\n}\n</code></pre>"}]}