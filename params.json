{"note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"The winner fakes it all!","name":"Fakeiteasy","google":"","body":"![Are you mocking me?](http://lh5.ggpht.com/_iTnDnty4mRk/TFsS15Nuu7I/AAAAAAAAANM/EuX4rAhiF0s/FakingMock.png)\r\n\r\n##It's faking amazing!\r\n\r\n    // Creating a fake object is just dead easy!\r\n    // No mocks, no stubs, everything's a fake!\r\n    var lollipop = A.Fake<ICandy>();\r\n    var shop = A.Fake<ICandyShop>();\r\n    \r\n    // To set up a call to return a value is also simple:\r\n    A.CallTo(() => shop.GetTopSellingCandy()).Returns(lollipop);\r\n    \r\n    // Use your fake as you would an actual instance of the faked type.\r\n    var developer = new SweetTooth();\r\n    developer.BuyTastiestCandy(shop);\r\n    \r\n    // Asserting uses the exact same syntax as when configuring calls,\r\n    // no need to teach yourself another syntax.\r\n    A.CallTo(() => shop.BuyCandy(lollipop)).MustHaveHappened();\r\n\r\nIn this example the lollipop instance is used as a stub and the shop instance is used as a mock but there's no need to know the difference, just fake it! Easy!\r\n\r\n##Description\r\nA .Net dynamic fake framework for creating all types of fake objects, mocks, stubs etc.\r\n\r\n* Easier semantics, all fake objects are just that - fakes - the use of the fakes determines whether they're mocks or stubs.\r\n* Context aware fluent interface guides the developer.\r\n* Full VB.Net support.\r\n\r\nDesigned for ease of use and for compatibility with both C# and VB.Net.\r\n\r\n##Syntax\r\n**Creating a fake object:**\r\nYou can create fake objects in two ways in FakeItEasy, either by calls to A.Fake-methods.\r\n\r\n    IFoo foo = A.Fake<IFoo>();\r\n\r\nOr you can create a fake object, that is a wrapper around the faked object, this object provides an api for configuring and asserting on the faked object, like this:\r\n\r\n    Fake<IFoo> fake = new Fake<IFoo>();\r\n    IFoo = fake.FakedObject;\r\n\r\n**Configuring a method on the fake object to return something:**\r\n\r\n    A.CallTo(() => foo.Bar()).Returns(\"test\");\r\n\r\n**Configuring calls to any method on an object**\r\n\r\n    A.CallTo(foo).Throws(new Exception());\r\n    A.CallTo(foo).WithReturnType<string>().Returns(\"hello world\");\r\n\r\n**When matching calls you can mix argument constraints and concrete arguments that are matched by equality:**\r\n\r\n    A.CallTo(() => foo.Bar(A<string>.Ignored, \"second argument\")).Throws(new Exception());\r\n\r\n**Return values can be produced at call time:**\r\n\r\n    int counter = 0;\r\n    A.CallTo(() => foo.Baz()).Returns(() => counter++);\r\n\r\n**Asserting**\r\n\r\n    A.CallTo(() => foo.Bar()).MustHaveHappened();\r\n    A.CallTo(() => foo.Bar()).MustNotHaveHappened();\r\n    A.CallTo(() => foo.Bar()).MustHaveHappened(Repeated.AtLeast.Once);\r\n    A.CallTo(() => foo.Bar()).MustHaveHappened(Repeated.Never);\r\n    A.CallTo(() => foo.Bar()).MustHaveHappened(Repeated.NoMoreThan.Times(4));\r\n    A.CallTo(() => foo.Bar()).MustHaveHappened(Repeated.Exactly.Twice);\r\n\r\n**Faking a class that takes arguments to constructor, no untyped object array, safe for refactoring:**\r\nIn order to pass arguments to the constructor of fakes of classes you'd use a lambda expression rather than the common method of passing object arrays representing the arguments. The expression will actually never be invoked so the constructor call in the following example will not be invoked but the arguments will be extracted from it.\r\n\r\n    var foo = A.Fake<Foo>(() => new Foo(\"string passed to constructor\"));\r\n\r\n**To raise an event on a fake object:**\r\n\r\n    foo.SomethingHappened += Raise.With(EventArgs.Empty).Now;\r\n\r\n**To raise an event on a fake object in VB:**\r\n\r\n    AddHandler foo.SomethingHappened, AddressOf Raise.With(EventArgs.Empty).Now\r\n\r\n    'If the event is an EventHandler(Of T) you can use the shorter syntax:\r\n\r\n    AddHandler foo.SomethingHappened, Raise.With(EventArgs.Empty).Go\r\n\r\n**Configuring a \"Sub\" call in VB:**\r\n\r\n    NextCall.To(foo).WithAnyArguments().Throws(New Exception())\r\n    foo.Bar(null, null)\r\n\r\n**Asserting on a \"Sub\" call in VB:**\r\n\r\n    NextCall.To(foo).WithAnyArguments().MustHaveHappened()\r\n    foo.Bar(null, null)\r\n\r\nIn .Net 4 VB supports lambda-subs as well:\r\n\r\n    A.CallTo(Sub() foo.Bar(A<object>.Ignored, A<object>.Ignored)).MustHaveHappened()\r\n\r\n**Configuring a \"Function\" in VB is just like in C#:**\r\n\r\n    A.CallTo(Function() foo.Baz()).Returns(10)"}